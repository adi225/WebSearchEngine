ibm s blue gene p massively parallel supercomputer parallel computing is a form of computation in which many calculations are carried out simultaneously 1 operating on the principle that large problems can often be divided into smaller ones which are then solved concurrently in parallel there are several different forms of parallel computing bit level instruction level data and task parallelism parallelism has been employed for many years mainly in high performance computing but interest in it has grown lately due to the physical constraints preventing frequency scaling 2 as power consumption and consequently heat generation by computers has become a concern in recent years 3 parallel computing has become the dominant paradigm in computer architecture mainly in the form of multicore processors 4 parallel computers can be roughly classified according to the level at which the hardware supports parallelism with multi core and multi processor computers having multiple processing elements within a single machine while clusters mpps and grids use multiple computers to work on the same task specialized parallel computer architectures are sometimes used alongside traditional processors for accelerating specific tasks parallel computer programs are more difficult to write than sequential ones 5 because concurrency introduces several new classes of potential software bugs of which race conditions are the most common communication and synchronization between the different subtasks are typically some of the greatest obstacles to getting good parallel program performance the maximum possible speed up of a program as a result of parallelization is known as amdahl s law contents 1 background 1 1 amdahl s law and gustafson s law 1 2 dependencies 1 3 race conditions mutual exclusion synchronization and parallel slowdown 1 4 fine grained coarse grained and embarrassing parallelism 1 5 consistency models 1 6 flynn s taxonomy 2 types of parallelism 2 1 bit level parallelism 2 2 instruction level parallelism 2 3 data parallelism 2 4 task parallelism 3 hardware 3 1 memory and communication 3 2 classes of parallel computers 3 2 1 multicore computing 3 2 2 symmetric multiprocessing 3 2 3 distributed computing 3 2 3 1 cluster computing 3 2 3 2 massive parallel processing 3 2 3 3 grid computing 3 2 4 specialized parallel computers 3 2 4 1 reconfigurable computing with field programmable gate arrays 3 2 4 2 general purpose computing on graphics processing units gpgpu 3 2 4 3 application specific integrated circuits 3 2 4 4 vector processors 4 software 4 1 parallel programming languages 4 2 automatic parallelization 4 3 application checkpointing 5 algorithmic methods 6 history 7 see also 8 references 9 further reading 10 external links edit background traditionally computer software has been written for serial computation 160 to solve a problem an algorithm is constructed and implemented as a serial stream of instructions 160 these instructions are executed on a central processing unit on one computer 160 only one instruction may execute at a time after that instruction is finished the next is executed 6 parallel computing on the other hand uses multiple processing elements simultaneously to solve a problem 160 this is accomplished by breaking the problem into independent parts so that each processing element can execute its part of the algorithm simultaneously with the others 160 the processing elements can be diverse and include resources such as a single computer with multiple processors several networked computers specialized hardware or any combination of the above 6 frequency scaling was the dominant reason for improvements in computer performance from the mid 1980s until 2004 160 the runtime of a program is equal to the number of instructions multiplied by the average time per instruction 160 maintaining everything else constant increasing the clock frequency decreases the average time it takes to execute an instruction 160 an increase in frequency thus decreases runtime for all compute bound programs 7 however power consumption by a chip is given by the equation p c v 2 f where p is power c is the capacitance being switched per clock cycle proportional to the number of transistors whose inputs change v is voltage and f is the processor frequency cycles per second 8 160 increases in frequency increase the amount of power used in a processor 160 increasing processor power consumption led ultimately to intel s may 2004 cancellation of its tejas and jayhawk processors which is generally cited as the end of frequency scaling as the dominant computer architecture paradigm 9 moore s law is the empirical observation that transistor density in a microprocessor doubles every 18 to 24 160 months 10 160 despite power consumption issues and repeated predictions of its end moore s law is still in effect 160 with the end of frequency scaling these additional transistors which are no longer used for frequency scaling can be used to add extra hardware for parallel computing edit amdahl s law and gustafson s law a graphical representation of amdahl s law 160 the speed up of a program from parallelization is limited by how much of the program can be parallelized 160 for example if 90 of the program can be parallelized the theoretical maximum speed up using parallel computing would be 10x no matter how many processors are used optimally the speed up from parallelization would be linear doubling the number of processing elements should halve the runtime and doubling it a second time should again halve the runtime 160 however very few parallel algorithms achieve optimal speed up 160 most of them have a near linear speed up for small numbers of processing elements which flattens out into a constant value for large numbers of processing elements the potential speed up of an algorithm on a parallel computing platform is given by amdahl s law originally formulated by gene amdahl in the 1960s 11 160 it states that a small portion of the program which cannot be parallelized will limit the overall speed up available from parallelization 160 a program solving a large mathematical or engineering problem will typically consist of several parallelizable parts and several non parallelizable sequential parts 160 if is the fraction of running time a program spends on non parallelizable parts then is the maximum speed up with parallelization of the program 160 if the sequential portion of a program accounts for 10 of the runtime we can get no more than a 10 speed up regardless of how many processors are added 160 this puts an upper limit on the usefulness of adding more parallel execution units 160 when a task cannot be partitioned because of sequential constraints the application of more effort has no effect on the schedule 160 the bearing of a child takes nine months no matter how many women are assigned 12 gustafson s law is another law in computing closely related to amdahl s law 13 160 it states that the speedup with processors is assume that a task has two independent parts a and b 160 b takes roughly 25 of the time of the whole computation 160 with effort a programmer may be able to make this part five times faster but this only reduces the time for the whole computation by a little 160 in contrast one may need to perform less work to make part 160 a twice as fast 160 this will make the computation much faster than by optimizing part 160 b even though b got a greater speed up 5 versus 2 both amdahl s law and gustafson s law assume that the running time of the sequential portion of the program is independent of the number of processors 160 amdahl s law assumes that the entire problem is of fixed size so that the total amount of work to be done in parallel is also independent of the number of processors whereas gustafson s law assumes that the total amount of work to be done in parallel varies linearly with the number of processors edit dependencies understanding data dependencies is fundamental in implementing parallel algorithms 160 no program can run more quickly than the longest chain of dependent calculations known as the critical path since calculations that depend upon prior calculations in the chain must be executed in order 160 however most algorithms do not consist of just a long chain of dependent calculations there are usually opportunities to execute independent calculations in parallel let p i and p j be two program segments 160 bernstein s conditions 14 describe when the two are independent and can be executed in parallel 160 for p i let i i be all of the input variables and o i the output variables and likewise for p j 160 p i and p j are independent if they satisfy violation of the first condition introduces a flow dependency corresponding to the first segment producing a result used by the second segment 160 the second condition represents an anti dependency when the second segment p j produces a variable needed by the first segment p i 160 the third and final condition represents an output dependency when two segments write to the same location the result comes from the logically last executed segment 15 consider the following functions which demonstrate several kinds of dependencies 1 function dep a b 2 c a b 3 d 3 c 4 end function operation 3 in dep a b cannot be executed before or even in parallel with operation 160 2 because operation 160 3 uses a result from operation 160 2 160 it violates condition 160 1 and thus introduces a flow dependency 1 function nodep a b 2 c a b 3 d 3 b 4 e a b 5 end function in this example there are no dependencies between the instructions so they can all be run in parallel bernstein s conditions do not allow memory to be shared between different processes 160 for that some means of enforcing an ordering between accesses is necessary such as semaphores barriers or some other synchronization method edit race conditions mutual exclusion synchronization and parallel slowdown subtasks in a parallel program are often called threads 160 some parallel computer architectures use smaller lightweight versions of threads known as fibers while others use bigger versions known as processes 160 however threads is generally accepted as a generic term for subtasks 160 threads will often need to update some variable that is shared between them 160 the instructions between the two programs may be interleaved in any order 160 for example consider the following program thread a thread b 1a read variable v 1b read variable v 2a add 1 to variable v 2b add 1 to variable v 3a write back to variable v 3b write back to variable v if instruction 1b is executed between 1a and 3a or if instruction 1a is executed between 1b and 3b the program will produce incorrect data 160 this is known as a race condition 160 the programmer must use a lock to provide mutual exclusion 160 a lock is a programming language construct that allows one thread to take control of a variable and prevent other threads from reading or writing it until that variable is unlocked 160 the thread holding the lock is free to execute its critical section the section of a program that requires exclusive access to some variable and to unlock the data when it is finished 160 therefore to guarantee correct program execution the above program can be rewritten to use locks thread a thread b 1a lock variable v 1b lock variable v 2a read variable v 2b read variable v 3a add 1 to variable v 3b add 1 to variable v 4a write back to variable v 4b write back to variable v 5a unlock variable v 5b unlock variable v one thread will successfully lock variable v while the other thread will be locked out unable to proceed until v is unlocked again 160 this guarantees correct execution of the program 160 locks while necessary to ensure correct program execution can greatly slow a program locking multiple variables using non atomic locks introduces the possibility of program deadlock 160 an atomic lock locks multiple variables all at once 160 if it cannot lock all of them it does not lock any of them 160 if two threads each need to lock the same two variables using non atomic locks it is possible that one thread will lock one of them and the second thread will lock the second variable 160 in such a case neither thread can complete and deadlock results many parallel programs require that their subtasks act in synchrony 160 this requires the use of a barrier 160 barriers are typically implemented using a software lock 160 one class of algorithms known as lock free and wait free algorithms altogether avoids the use of locks and barriers 160 however this approach is generally difficult to implement and requires correctly designed data structures not all parallelization results in speed up 160 generally as a task is split up into more and more threads those threads spend an ever increasing portion of their time communicating with each other 160 eventually the overhead from communication dominates the time spent solving the problem and further parallelization that is splitting the workload over even more threads increases rather than decreases the amount of time required to finish 160 this is known as parallel slowdown edit fine grained coarse grained and embarrassing parallelism applications are often classified according to how often their subtasks need to synchronize or communicate with each other 160 an application exhibits fine grained parallelism if its subtasks must communicate many times per second it exhibits coarse grained parallelism if they do not communicate many times per second and it is embarrassingly parallel if they rarely or never have to communicate 160 embarrassingly parallel applications are considered the easiest to parallelize edit consistency models main article consistency model parallel programming languages and parallel computers must have a consistency model also known as a memory model 160 the consistency model defines rules for how operations on computer memory occur and how results are produced one of the first consistency models was leslie lamport s sequential consistency model 160 sequential consistency is the property of a parallel program that its parallel execution produces the same results as a sequential program 160 specifically a program is sequentially consistent if 160 the results of any execution is the same as if the operations of all the processors were executed in some sequential order and the operations of each individual processor appear in this sequence in the order specified by its program 16 software transactional memory is a common type of consistency model 160 software transactional memory borrows from database theory the concept of atomic transactions and applies them to memory accesses mathematically these models can be represented in several ways 160 petri nets which were introduced in carl adam petri s 1962 doctoral thesis were an early attempt to codify the rules of consistency models 160 dataflow theory later built upon these and dataflow architectures were created to physically implement the ideas of dataflow theory 160 beginning in the late 1970s process calculi such as calculus of communicating systems and communicating sequential processes were developed to permit algebraic reasoning about systems composed of interacting components 160 more recent additions to the process calculus family such as the calculus have added the capability for reasoning about dynamic topologies 160 logics such as lamport s tla and mathematical models such as traces and actor event diagrams have also been developed to describe the behavior of concurrent systems edit flynn s taxonomy michael j flynn created one of the earliest classification systems for parallel and sequential computers and programs now known as flynn s taxonomy 160 flynn classified programs and computers by whether they were operating using a single set or multiple sets of instructions whether or not those instructions were using a single or multiple sets of data 160 single instruction multiple instruction single data sisd misd multiple data simd mimd the single instruction single data sisd classification is equivalent to an entirely sequential program 160 the single instruction multiple data simd classification is analogous to doing the same operation repeatedly over a large data set 160 this is commonly done in signal processing applications 160 multiple instruction single data misd is a rarely used classification 160 while computer architectures to deal with this were devised such as systolic arrays few applications that fit this class materialized 160 multiple instruction multiple data mimd programs are by far the most common type of parallel programs according to david a patterson and john l hennessy some machines are hybrids of these categories of course but this classic model has survived because it is simple easy to understand and gives a good first approximation 160 it is also perhaps because of its understandability the most widely used scheme 17 edit types of parallelism edit bit level parallelism main article bit level parallelism from the advent of very large scale integration vlsi computer chip fabrication technology in the 1970s until about 1986 speed up in computer architecture was driven by doubling computer word size the amount of information the processor can manipulate per cycle 18 increasing the word size reduces the number of instructions the processor must execute to perform an operation on variables whose sizes are greater than the length of the word for example where an 8 bit processor must add two 16 bit integers the processor must first add the 8 160 lower order bits from each integer using the standard addition instruction then add the 8 160 higher order bits using an add with carry instruction and the carry bit from the lower order addition thus an 8 bit processor requires two instructions to complete a single operation where a 16 bit processor would be able to complete the operation with a single instruction historically 4 bit microprocessors were replaced with 8 bit then 16 bit then 32 bit microprocessors this trend generally came to an end with the introduction of 32 bit processors which has been a standard in general purpose computing for two decades not until recently c 2003 2004 with the advent of x86 64 architectures have 64 bit processors become commonplace edit instruction level parallelism main article instruction level parallelism a canonical five stage pipeline in a risc machine if instruction fetch id instruction decode ex execute mem memory access wb register write back a computer program is in essence a stream of instructions executed by a processor these instructions can be re ordered and combined into groups which are then executed in parallel without changing the result of the program this is known as instruction level parallelism advances in instruction level parallelism dominated computer architecture from the mid 1980s until the mid 1990s 19 modern processors have multi stage instruction pipelines each stage in the pipeline corresponds to a different action the processor performs on that instruction in that stage a processor with an n stage pipeline can have up to n different instructions at different stages of completion the canonical example of a pipelined processor is a risc processor with five stages instruction fetch decode execute memory access and write back the pentium 4 processor had a 35 stage pipeline 20 a five stage pipelined superscalar processor capable of issuing two instructions per cycle it can have two instructions in each stage of the pipeline for a total of up to 10 160 instructions shown in green being simultaneously executed in addition to instruction level parallelism from pipelining some processors can issue more than one instruction at a time these are known as superscalar processors instructions can be grouped together only if there is no data dependency between them scoreboarding and the tomasulo algorithm which is similar to scoreboarding but makes use of register renaming are two of the most common techniques for implementing out of order execution and instruction level parallelism edit data parallelism main article data parallelism data parallelism is parallelism inherent in program loops which focuses on distributing the data across different computing nodes to be processed in parallel parallelizing loops often leads to similar not necessarily identical operation sequences or functions being performed on elements of a large data structure 21 many scientific and engineering applications exhibit data parallelism for example gps receivers 22 and other electronic devices often have an array of identical processing elements that process data in parallel often people designing such systems try to maximize the number of processing elements maximizing the data parallelism even if they end up using bit serial processing sacrificing bit level parallelism 23 24 25 a loop carried dependency is the dependence of a loop iteration on the output of one or more previous iterations loop carried dependencies prevent the parallelization of loops for example consider the following pseudocode that computes the first few fibonacci numbers 1 prev1 0 2 prev2 1 4 do 5 cur prev1 prev2 6 prev1 prev2 7 prev2 cur 8 while cur lt 10 this loop cannot be parallelized because cur depends on itself prev2 and prev1 which are computed in each loop iteration since each iteration depends on the result of the previous one they cannot be performed in parallel as the size of a problem gets bigger the amount of data parallelism available usually does as well 26 often n serial processors will take less fpga area and and have higher total performance than a single bit parallel n bit processor 27 28 edit task parallelism main article task parallelism task parallelism is the characteristic of a parallel program that entirely different calculations can be performed on either the same or different sets of data 21 this contrasts with data parallelism where the same calculation is performed on the same or different sets of data task parallelism does not usually scale with the size of a problem 26 edit hardware edit memory and communication main memory in a parallel computer is either shared memory shared between all processing elements in a single address space or distributed memory in which each processing element has its own local address space 29 distributed memory refers to the fact that the memory is logically distributed but often implies that it is physically distributed as well distributed shared memory and memory virtualization combine the two approaches where the processing element has its own local memory and access to the memory on non local processors accesses to local memory are typically faster than accesses to non local memory a logical view of a non uniform memory access numa architecture processors in one directory can access that directory s memory with less latency than they can access memory in the other directory s memory computer architectures in which each element of main memory can be accessed with equal latency and bandwidth are known as uniform memory access uma systems typically that can be achieved only by a shared memory system in which the memory is not physically distributed a system that does not have this property is known as a non uniform memory access numa architecture distributed memory systems have non uniform memory access computer systems make use of caches small fast memories located close to the processor which store temporary copies of memory values nearby in both the physical and logical sense parallel computer systems have difficulties with caches that may store the same value in more than one location with the possibility of incorrect program execution these computers require a cache coherency system which keeps track of cached values and strategically purges them thus ensuring correct program execution bus snooping is one of the most common methods for keeping track of which values are being accessed and thus should be purged designing large high performance cache coherence systems is a very difficult problem in computer architecture as a result shared memory computer architectures do not scale as well as distributed memory systems do 29 processor processor and processor memory communication can be implemented in hardware in several ways including via shared either multiported or multiplexed memory a crossbar switch a shared bus or an interconnect network of a myriad of topologies including star ring tree hypercube fat hypercube a hypercube with more than one processor at a node or n dimensional mesh parallel computers based on interconnect networks need to have some kind of routing to enable the passing of messages between nodes that are not directly connected the medium used for communication between the processors is likely to be hierarchical in large multiprocessor machines edit classes of parallel computers parallel computers can be roughly classified according to the level at which the hardware supports parallelism this classification is broadly analogous to the distance between basic computing nodes these are not mutually exclusive for example clusters of symmetric multiprocessors are relatively common edit multicore computing main article multi core computing a multicore processor is a processor that includes multiple execution units cores on the same chip these processors differ from superscalar processors which can issue multiple instructions per cycle from one instruction stream thread in contrast a multicore processor can issue multiple instructions per cycle from multiple instruction streams each core in a multicore processor can potentially be superscalar as well that is on every cycle each core can issue multiple instructions from one instruction stream simultaneous multithreading of which intel s hyperthreading is the best known was an early form of pseudo multicoreism a processor capable of simultaneous multithreading has only one execution unit core but when that execution unit is idling such as during a cache miss it uses that execution unit to process a second thread ibm s cell microprocessor designed for use in the sony playstation 3 is another prominent multicore processor edit symmetric multiprocessing main article symmetric multiprocessing a symmetric multiprocessor smp is a computer system with multiple identical processors that share memory and connect via a bus 30 bus contention prevents bus architectures from scaling as a result smps generally do not comprise more than 32 160 processors 31 because of the small size of the processors and the significant reduction in the requirements for bus bandwidth achieved by large caches such symmetric multiprocessors are extremely cost effective provided that a sufficient amount of memory bandwidth exists 30 edit distributed computing main article distributed computing a distributed computer also known as a distributed memory multiprocessor is a distributed memory computer system in which the processing elements are connected by a network distributed computers are highly scalable edit cluster computing main article computer cluster a beowulf cluster a cluster is a group of loosely coupled computers that work together closely so that in some respects they can be regarded as a single computer 32 clusters are composed of multiple standalone machines connected by a network while machines in a cluster do not have to be symmetric load balancing is more difficult if they are not the most common type of cluster is the beowulf cluster which is a cluster implemented on multiple identical commercial off the shelf computers connected with a tcp ip ethernet local area network 33 beowulf technology was originally developed by thomas sterling and donald becker the vast majority of the top500 supercomputers are clusters 34 edit massive parallel processing main article massively parallel computing a massively parallel processor mpp is a single computer with many networked processors mpps have many of the same characteristics as clusters but mpps have specialized interconnect networks whereas clusters use commodity hardware for networking mpps also tend to be larger than clusters typically having far more than 100 160 processors 35 in a mpp each cpu contains its own memory and copy of the operating system and application each subsystem communicates with the others via a high speed interconnect 36 a cabinet from blue gene l ranked as the fourth fastest supercomputer in the world according to the 11 2008 top500 rankings blue gene l is a massively parallel processor blue gene l the fifth fastest supercomputer in the world according to the june 2009 top500 ranking is a mpp edit grid computing main article distributed computing distributed computing is the most distributed form of parallel computing it makes use of computers communicating over the internet to work on a given problem because of the low bandwidth and extremely high latency available on the internet distributed computing typically deals only with embarrassingly parallel problems many distributed computing applications have been created of which seti home and folding home are the best known examples 37 most grid computing applications use middleware software that sits between the operating system and the application to manage network resources and standardize the software interface the most common distributed computing middleware is the berkeley open infrastructure for network computing boinc often distributed computing software makes use of spare cycles performing computations at times when a computer is idling edit specialized parallel computers within parallel computing there are specialized parallel devices that remain niche areas of interest while not domain specific they tend to be applicable to only a few classes of parallel problems edit reconfigurable computing with field programmable gate arrays reconfigurable computing is the use of a field programmable gate array fpga as a co processor to a general purpose computer an fpga is in essence a computer chip that can rewire itself for a given task fpgas can be programmed with hardware description languages such as vhdl or verilog however programming in these languages can be tedious several vendors have created c to hdl languages that attempt to emulate the syntax and or semantics of the c programming language with which most programmers are familiar the best known c to hdl languages are mitrion c impulse c dime c and handel c specific subsets of systemc based on c can also be used for this purpose amd s decision to open its hypertransport technology to third party vendors has become the enabling technology for high performance reconfigurable computing 38 according to michael r d amour chief operating officer of drc computer corporation when we first walked into amd they called us the socket stealers now they call us their partners 38 edit general purpose computing on graphics processing units gpgpu main article gpgpu nvidia s tesla gpgpu card general purpose computing on graphics processing units gpgpu is a fairly recent trend in computer engineering research gpus are co processors that have been heavily optimized for computer graphics processing 39 computer graphics processing is a field dominated by data parallel operations particularly linear algebra matrix operations in the early days gpgpu programs used the normal graphics apis for executing programs however several new programming languages and platforms have been built to do general purpose computation on gpus with both nvidia and amd releasing programming environments with cuda and stream sdk respectively other gpu programming languages include brookgpu peakstream and rapidmind nvidia has also released specific products for computation in their tesla series the technology consortium khronos group has released the opencl specification which is a framework for writing programs that execute across platforms consisting of cpus and gpus amd apple intel nvidia and others are supporting opencl edit application specific integrated circuits main article application specific integrated circuit several application specific integrated circuit asic approaches have been devised for dealing with parallel applications 40 41 42 because an asic is by definition specific to a given application it can be fully optimized for that application as a result for a given application an asic tends to outperform a general purpose computer however asics are created by x ray lithography this process requires a mask which can be extremely expensive a single mask can cost over a million us dollars 43 the smaller the transistors required for the chip the more expensive the mask will be meanwhile performance increases in general purpose computing over time as described by moore s law tend to wipe out these gains in only one or two chip generations 38 high initial cost and the tendency to be overtaken by moore s law driven general purpose computing has rendered asics unfeasible for most parallel computing applications however some have been built one example is the peta flop riken mdgrape 3 machine which uses custom asics for molecular dynamics simulation edit vector processors main article vector processor the cray 1 is the most famous vector processor a vector processor is a cpu or computer system that can execute the same instruction on large sets of data vector processors have high level operations that work on linear arrays of numbers or vectors an example vector operation is a b c where a b and c are each 64 element vectors of 64 bit floating point numbers 44 they are closely related to flynn s simd classification 44 cray computers became famous for their vector processing computers in the 1970s and 1980s however vector processors both as cpus and as full computer systems have generally disappeared modern processor instruction sets do include some vector processing instructions such as with altivec and streaming simd extensions sse edit software edit parallel programming languages main article list of concurrent and parallel programming languages concurrent programming languages libraries apis and parallel programming models such as algorithmic skeletons have been created for programming parallel computers these can generally be divided into classes based on the assumptions they make about the underlying memory architecture shared memory distributed memory or shared distributed memory shared memory programming languages communicate by manipulating shared memory variables distributed memory uses message passing posix threads and openmp are two of most widely used shared memory apis whereas message passing interface mpi is the most widely used message passing system api 45 one concept used in programming parallel programs is the future concept where one part of a program promises to deliver a required datum to another part of a program at some future time caps entreprise and pathscale are also coordinating their effort to make hmpp hybrid multicore parallel programming directives an open standard denoted openhmpp the openhmpp directive based programming model offers a syntax to efficiently offload computations on hardware accelerators and to optimize data movement to from the hardware memory openhmpp directives describe remote procedure call rpc on an accelerator device e g gpu or more generally a set of cores the directives annotate c or fortran codes to describe two sets of functionalities the offloading of procedures denoted codelets onto a remote device and the optimization of data transfers between the cpu main memory and the accelerator memory edit automatic parallelization main article automatic parallelization automatic parallelization of a sequential program by a compiler is the holy grail of parallel computing despite decades of work by compiler researchers automatic parallelization has had only limited success 46 mainstream parallel programming languages remain either explicitly parallel or at best partially implicit in which a programmer gives the compiler directives for parallelization a few fully implicit parallel programming languages exist sisal parallel haskell and for fpgas system c mitrion c vhdl and verilog edit application checkpointing main article application checkpointing as a computer system grows in complexity the mean time between failures usually decreases application checkpointing is a technique whereby the computer system takes a snapshot of the application 160 a record of all current resource allocations and variable states akin to a core dump this information can be used to restore the program if the computer should fail application checkpointing means that the program has to restart from only its last checkpoint rather than the beginning while checkpointing provides benefits in a variety of situations it is specially useful in highly parallel systems with a large number of processors used in high performance computing 47 edit algorithmic methods as parallel computers become larger and faster it becomes feasible to solve problems that previously took too long to run parallel computing is used in a wide range of fields from bioinformatics protein folding and sequence analysis to economics mathematical finance common types of problems found in parallel computing applications are 48 dense linear algebra sparse linear algebra spectral methods such as cooley tukey fast fourier transform n body problems such as barnes hut simulation structured grid problems such as lattice boltzmann methods unstructured grid problems such as found in finite element analysis monte carlo simulation combinational logic such as brute force cryptographic techniques graph traversal such as sorting algorithms dynamic programming branch and bound methods graphical models such as detecting hidden markov models and constructing bayesian networks finite state machine simulation edit history main article history of computing illiac iv perhaps the most infamous of supercomputers 49 the origins of true mimd parallelism go back to federico luigi conte menabrea and his sketch of the analytic engine invented by charles babbage 50 51 ibm introduced the 704 in 1954 through a project in which gene amdahl was one of the principal architects it became the first commercially available computer to use fully automatic floating point arithmetic commands 52 in april 1958 s gill ferranti discussed parallel programming and the need for branching and waiting 53 also in 1958 ibm researchers john cocke and daniel slotnick discussed the use of parallelism in numerical calculations for the first time 54 burroughs corporation introduced the d825 in 1962 a four processor computer that accessed up to 16 memory modules through a crossbar switch 55 in 1967 amdahl and slotnick published a debate about the feasibility of parallel processing at american federation of information processing societies conference 54 it was during this debate that amdahl s law was coined to define the limit of speed up due to parallelism in 1969 us company honeywell introduced its first multics system a symmetric multiprocessor system capable of running up to eight processors in parallel 54 c mmp a 1970s multi processor project at carnegie mellon university was among the first multiprocessors with more than a few processors 51 the first bus connected multi processor with snooping caches was the synapse n 1 in 1984 51 simd parallel computers can be traced back to the 1970s the motivation behind early simd computers was to amortize the gate delay of the processor s control unit over multiple instructions 56 in 1964 slotnick had proposed building a massively parallel computer for the lawrence livermore national laboratory 54 his design was funded by the us air force which was the earliest simd parallel computing effort illiac iv 54 the key to its design was a fairly high parallelism with up to 256 160 processors which allowed the machine to work on large datasets in what would later be known as vector processing however illiac iv was called the most infamous of supercomputers because the project was only one fourth completed but took 11 160 years and cost almost four times the original estimate 49 when it was finally ready to run its first real application in 1976 it was outperformed by existing commercial supercomputers such as the cray 1 edit see also list of important publications in concurrent parallel and distributed computing list of distributed computing conferences concurrency computer science synchronous programming content addressable parallel processor transputer edit references gottlieb allan almasi george s 1989 highly parallel computing redwood city calif benjamin cummings isbn 160 0 8053 0177 1 http dl acm org citation cfm id 160438 s v adve et al november 2008 parallel computing research at illinois the upcrc agenda pdf parallel illinois university of illinois at urbana champaign the main techniques for these performance benefits 160 increased clock frequency and smarter but increasingly complex architectures 160 are now hitting the so called power wall the computer industry has accepted that future performance increases must largely come from increasing the number of processors or cores on a die rather than making a single core go faster asanovic et al old conventional wisdom power is free but transistors are expensive new conventional wisdom is that power is expensive but transistors are free asanovic krste et al december 18 2006 the landscape of parallel computing research a view from berkeley pdf university of california berkeley technical report no ucb eecs 2006 183 old conventional wisdom increasing clock frequency is the primary method of improving processor performance new conventional wisdom increasing parallelism is the primary method of improving processor performance 160 even representatives from intel a company generally associated with the higher clock speed is better position warned that traditional approaches to maximizing performance through maximizing clock speed have been pushed to their limit hennessy john l patterson david a larus james r 1999 computer organization and design 160 the hardware software interface 2 ed 3rd print ed san francisco kaufmann isbn 160 1 55860 428 6 a b barney blaise introduction to parallel computing lawrence livermore national laboratory http www llnl gov computing tutorials parallel comp retrieved 2007 11 09 hennessy john l patterson david a 2002 computer architecture a quantitative approach 3rd ed san francisco calif international thomson p 160 43 isbn 160 1 55860 724 2 rabaey jan m 1996 digital integrated circuits 160 a design perspective upper saddle river n j prentice hall p 160 235 isbn 160 0 13 178609 1 flynn laurie j 8 may 2004 intel halts development of 2 new microprocessors new york times http www nytimes com 2004 05 08 business 08chip html ex 1399348800 amp en 98cc44ca97b1a562 amp ei 5007 retrieved 5 june 2012 moore gordon e 1965 cramming more components onto integrated circuits pdf electronics magazine p 160 4 ftp download intel com museum moores law articles press releases gordon moore 1965 article pdf retrieved 2006 11 11 amdahl gene m 1967 validity of the single processor approach to achieving large scale computing capabilities proceeding afips 67 spring proceedings of the april 18 20 1967 spring joint computer conference 483 485 doi 10 1145 1465482 1465560 http dl acm org citation cfm id 160438 brooks frederick p 1996 the mythical man month essays on software engineering anniversary ed repr with corr 5 dr ed reading mass u a addison wesley isbn 160 0 201 83595 9 gustafson john l may 1988 reevaluating amdahl s law communications of the acm 31 5 532 533 doi 10 1145 42411 42415 http www scl ameslab gov publications gus amdahlslaw amdahls html bernstein a j 1 october 1966 analysis of programs for parallel processing ieee transactions on electronic computers ec 15 5 757 763 doi 10 1109 pgec 1966 264565 roosta seyed h 2000 parallel processing and parallel algorithms 160 theory and computation new york ny u a springer p 160 114 isbn 160 0 387 98716 9 lamport leslie 1 september 1979 how to make a multiprocessor computer that correctly executes multiprocess programs ieee transactions on computers c 28 9 690 691 doi 10 1109 tc 1979 1675439 patterson and hennessy p 160 748 singh david culler 160 j p 1997 parallel computer architecture nachdr ed san francisco morgan kaufmann publ p 160 15 isbn 160 1 55860 343 3 culler et al p 160 15 patt yale april 2004 the microprocessor ten years from now what are the challenges how do we meet them wmv distinguished lecturer talk at carnegie mellon university retrieved on november 7 2007 a b culler et al p 160 124 l kurz g kappen t coenen and t g noll comparison of massive parallel and fft based acquisition architectures for multi constellation user receivers 2010 ahmad darabiha anthony chan carusone frank r kschischang power reduction techniques for ldpc decoders brian m h li and philip h w leong serial and parallel fpga based variable block size motion estimation processors for h 264 duane marcy fred schlereth parija kshirsagar and anvith katte mahabalagiri syr eecs 2010 07 a bit serial approach to massively parallel floating point operations on an fpga 2010 11 23 a b culler et al p 160 125 raymond j andraka building a high performance bit serial processor in an fpga ahmad darabiha anthony chan carusone and frank r kschischang a bit serial approximate min sum ldpc decoder and fpga implementation 1 a b patterson and hennessy p 160 713 a b hennessy and patterson p 160 549 patterson and hennessy p 160 714 what is clustering webopedia computer dictionary retrieved on november 7 2007 beowulf definition pc magazine retrieved on november 7 2007 architecture share for 06 2007 top500 supercomputing sites clusters make up 74 60 of the machines on the list retrieved on november 7 2007 hennessy and patterson p 160 537 mpp definition pc magazine retrieved on november 7 2007 kirkpatrick scott 2003 computer science rough times ahead science 299 5607 668 669 doi 10 1126 science 1081623 pmid 160 12560537 a b c d amour michael r chief operating officer drc computer corporation standard reconfigurable computing invited speaker at the university of delaware february 28 2007 boggan sha kia and daniel m pressel august 2007 gpus an emerging platform for general purpose computation pdf arl sr 154 u s army research lab retrieved on november 7 2007 maslennikov oleg 2002 systematic generation of executing programs for processor elements in parallel asic or fpga based systems and their transformation into vhdl descriptions of processor element control units lecture notes in computer science 2328 2002 p 160 272 shimokawa y y fuwa and n aramaki 18 21 nov 1991 a parallel asic vlsi neurocomputer for a large number of neurons and billion connections per second speed international joint conference on neural networks 3 2162 2167 doi 10 1109 ijcnn 1991 170708 isbn 160 0 7803 0227 3 http ieeexplore ieee org xpl freeabs all jsp arnumber 170708 acken kevin p irwin mary jane owens robert m 1 january 1998 the journal of vlsi signal processing 19 2 97 113 doi 10 1023 a 1008005616596 kahng andrew b june 21 2004 scoping the problem of dfm in the semiconductor industry university of california san diego future design for manufacturing dfm technology must reduce design non recoverable expenditure cost and directly address manufacturing non recoverable expenditures 160 the cost of a mask set and probe card 160 which is well over 1 160 million at the 90 160 nm technology node and creates a significant damper on semiconductor based innovation a b patterson and hennessy p 160 751 the sidney fernbach award given to mpi inventor bill gropp refers to mpi as the dominant hpc communications interface shen john paul mikko h lipasti 2004 modern processor design 160 fundamentals of superscalar processors 1st ed dubuque iowa mcgraw hill p 160 561 isbn 160 0 07 057064 7 however the holy grail of such research 160 automated parallelization of serial programs 160 has yet to materialize while automated parallelization of certain classes of algorithms has been demonstrated such success has largely been limited to scientific and numeric applications with predictable flow control e g nested loop structures with statically determined iteration counts and statically analyzable memory access patterns e g walks over large multidimensional arrays of float point data encyclopedia of parallel computing volume 4 by david padua 2011 isbn 0387097651 page 265 asanovic krste et al december 18 2006 the landscape of parallel computing research a view from berkeley pdf university of california berkeley technical report no ucb eecs 2006 183 see table on pages 17 19 a b patterson and hennessy pp 160 749 50 although successful in pushing several technologies useful in later projects the illiac iv failed as a computer costs escalated from the 8 160 million estimated in 1966 to 31 160 million by 1972 despite the construction of only a quarter of the planned machine 160 it was perhaps the most infamous of supercomputers the project started in 1965 and ran its first real application in 1976 menabrea l f 1842 sketch of the analytic engine invented by charles babbage biblioth que universelle de gen ve retrieved on november 7 2007 a b c patterson and hennessy p 160 753 da cruz frank 2003 columbia university computing history the ibm 704 columbia university http www columbia edu acis history 704 html retrieved 2008 01 08 parallel programming s gill the computer journal vol 1 1 pp2 10 british computer society april 1958 a b c d e wilson gregory v 1994 the history of the development of parallel computing virginia tech norfolk state university interactive learning with a digital library in computer science http ei cs vt edu history parallel html retrieved 2008 01 08 anthes gry november 19 2001 the power of parallelism computerworld http www computerworld com action article do command viewarticlebasic amp articleid 65878 retrieved 2008 01 08 patterson and hennessy p 160 749 edit further reading rodriguez c villagra m baran b 29 august 2008 asynchronous team algorithms for boolean satisfiability bio inspired models of network information and computing systems 2007 bionetics 2007 2nd 66 69 doi 10 1109 bimnics 2007 4610083 http ieeexplore ieee org xpl articledetails jsp arnumber 4610083 edit external links listen to this article info dl sorry your browser either has javascript disabled or does not have any supported player you can download the clip or download a player to play the clip in your browser this audio file was created from a revision of the parallel computing article dated 2011 10 29 and does not reflect subsequent edits to the article audio help more spoken articles wikibooks has a book on the topic of distributed systems go parallel translating multicore power into application performance parallel computing at the open directory project lawrence livermore national laboratory introduction to parallel computing comparing programmability of open mp and pthreads what makes parallel programming hard designing and building parallel programs by ian foster internet parallel computing archive parallel processing topic area at ieee distributed computing online parallel computing works free on line book frontiers of supercomputing free on line book covering topics like algorithms and industrial applications universal parallel computing research center course in parallel programming at columbia university in collaboration with ibm t j watson x10 project parallel and distributed gr obner bases computation in jas course in parallel computing at university of wisconsin madison openhmpp a new standard for manycore v t e parallel computing general cloud computing high performance computing cluster computing distributed computing grid computing levels bit instruction data task threads superthreading hyperthreading theory amdahl s law gustafson s law cost efficiency karp flatt metric slowdown speedup elements process thread fiber pram instruction window coordination multiprocessing multithreading computer architecture memory coherency cache coherency cache invalidation barrier synchronization application checkpointing programming models implicit parallelism explicit parallelism concurrency flynn s taxonomy sisd simd misd mimd spmd thread computer science non blocking algorithm hardware multiprocessor symmetric asymmetric memory numa coma distributed shared distributed shared smt mpp superscalar vector processor supercomputer beowulf apis ateji px posix threads openmp openhmpp openacc pvm mpi upc intel threading building blocks intel cilk plus boost thread global arrays charm cilk co array fortran opencl cuda dryad c amp problems embarrassingly parallel software lockout scalability race condition deadlock livelock deterministic algorithm parallel slowdown category parallel computing media related to parallel computing at wikimedia commons 