this article may require cleanup to meet wikipedia s quality standards no cleanup reason has been specified please help improve this article if you can june 2010 programming paradigms action agent oriented aspect oriented automata based component based flow based pipelined concatenative concurrent computing relativistic programming data driven declarative contrast imperative constraint dataflow cell oriented spreadsheets reactive intensional functional logic abductive logic answer set constraint logic functional logic inductive logic end user programming event driven service oriented time driven expression oriented feature oriented function level contrast value level generic imperative contrast declarative procedural language oriented discipline specific domain specific grammar oriented dialecting intentional metaprogramming automatic reflective attribute oriented homoiconic template policy based non structured contrast structured array nondeterministic parallel computing process oriented programming in the large and small semantic structured contrast non structured modular contrast monolithic object oriented by separation of concerns aspect oriented role oriented subject oriented class based prototype based recursive value level contrast function level v t e logic programming is one of the 4 main programming paradigms its theory of computation is based on first order logic programming languages such as prolog and datalog implement it a form of logical sentences commonly found in logic programming but not exclusively is the horn clause an example is p x y if q x and r y some logic programming languages accept other logical sentences such as the choice sentence in answer set programming logical sentences can be understood purely declaratively they can also be understood procedurally as goal reduction procedures 160 to solve p x y first solve q x then solve r y the programmer can use the declarative reading of logic programs to verify their correctness in addition the programmer can use the known behaviour of the program executor to develop a procedural understanding of his program this may be helpful when seeking better execution speed however many logically based program transformation techniques have been developed to transform logic programs automatically and make them efficient contents 1 history 2 prolog 3 negation as failure 4 problem solving 5 knowledge representation 6 abductive logic programming 7 metalogic programming 8 constraint logic programming 9 concurrent logic programming 10 inductive logic programming 11 higher order logic programming 12 linear logic programming 13 see also 14 references 14 1 general introductions 14 2 other sources 15 further reading 16 external links edit history the use of mathematical logic to represent and execute computer programs is also a feature of the lambda calculus developed by alonzo church in the 1930s however the first proposal to use the clausal form of logic for representing computer programs was made by cordell green 1969 this used an axiomatization of a subset of lisp together with a representation of an input output relation to compute the relation by simulating the execution of the program in lisp foster and elcock s absys 1969 on the other hand employed a combination of equations and lambda calculus in an assertional programming language which places no constraints on the order in which operations are performed logic programming in its present form can be traced back to debates in the late 1960s and early 1970s about declarative versus procedural representations of knowledge in artificial intelligence advocates of declarative representations were notably working at stanford associated with john mccarthy bertram raphael and cordell green and in edinburgh with john alan robinson an academic visitor from syracuse university pat hayes and robert kowalski advocates of procedural representations were mainly centered at mit under the leadership of marvin minsky and seymour papert although it was based on the proof methods of logic planner developed at mit was the first language to emerge within this proceduralist paradigm hewitt 1969 planner featured pattern directed invocation of procedural plans from goals i e goal reduction or backward chaining and from assertions i e forward chaining the most influential implementation of planner was the subset of planner called micro planner implemented by gerry sussman eugene charniak and terry winograd it was used to implement winograd s natural language understanding program shrdlu which was a landmark at that time to cope with the very limited memory systems at the time planner used a backtracking control structure so that only one possible computation path had to be stored at a time planner gave rise to the programming languages qa 4 popler conniver qlisp and the concurrent language ether hayes and kowalski in edinburgh tried to reconcile the logic based declarative approach to knowledge representation with planner s procedural approach hayes 1973 developed an equational language golux in which different procedures could be obtained by altering the behavior of the theorem prover kowalski on the other hand showed how sl resolution treats implications as goal reduction procedures kowalski collaborated with colmerauer in marseille who developed these ideas in the design and implementation of the programming language prolog prolog gave rise to the programming languages alf fril g del mercury oz ciao visual prolog xsb and prolog as well as a variety of concurrent logic programming languages see shapiro 1989 for a survey constraint logic programming languages and datalog in 1997 the association of logic programming bestowed to fifteen recognized researchers in logic programming the title founders of logic programming to recognize them as pioneers in the field maurice bruynooghe belgium jacques cohen us alain colmerauer france keith clark uk veronica dahl canada argentina maarten van emden canada herve gallaire france robert kowalski uk jack minker us fernando pereira us luis moniz pereira portugal ray reiter canada j alan robinson us peter szeredi hungary david h d warren uk edit prolog main article prolog the programming language prolog was developed in 1972 by alain colmerauer it emerged from a collaboration between colmerauer in marseille and robert kowalski in edinburgh colmerauer was working on natural language understanding using logic to represent semantics and using resolution for question answering during the summer of 1971 colmerauer and kowalski discovered that the clausal form of logic could be used to represent formal grammars and that resolution theorem provers could be used for parsing they observed that some theorem provers like hyper resolution behave as bottom up parsers and others like sl resolution 1971 behave as top down parsers it was in the following summer of 1972 that kowalski again working with colmerauer developed the procedural interpretation of implications this dual declarative procedural interpretation later became formalised in the prolog notation h 160 b 1 b n which can be read and used both declaratively and procedurally it also became clear that such clauses could be restricted to definite clauses or horn clauses where h b 1 b n are all atomic predicate logic formulae and that sl resolution could be restricted and generalised to lush or sld resolution kowalski s procedural interpretation and lush were described in a 1973 memo published in 1974 colmerauer with philippe roussel used this dual interpretation of clauses as the basis of prolog which was implemented in the summer and autumn of 1972 the first prolog program also written in 1972 and implemented in marseille was a french question answering system the use of prolog as a practical programming language was given great momentum by the development of a compiler by david warren in edinburgh in 1977 experiments demonstrated that edinburgh prolog could compete with the processing speed of other symbolic programming languages such as lisp edinburgh prolog became the de facto standard and strongly influenced the definition of iso standard prolog edit negation as failure main article negation as failure micro planner had a construct called thnot which when applied to an expression returns the value true if and only if the evaluation of the expression fails an equivalent operator is normally built in in modern prolog s implementations and has been called negation as failure it is normally written as not p where p is an atom whose variables normally have been instantiated by the time not p is invoked a more cryptic but standard syntax is p negation as failure literals can occur as conditions not b i in the body of program clauses the logical status of negation as failure was unresolved until keith clark 1978 showed that under certain natural conditions it is a correct and sometimes complete implementation of classical negation with respect to the completion of the program completion amounts roughly to regarding the set of all the program clauses with the same predicate on the left hand side say h 160 body 1 h 160 body k as a definition of the predicate h iff body 1 or or body k where iff means if and only if writing the completion also requires explicit use of the equality predicate and the inclusion of a set of appropriate axioms for equality however the implementation of negation by failure needs only the if halves of the definitions without the axioms of equality the notion of completion is closely related to mccarthy s circumscription semantics for default reasoning and to the closed world assumption as an alternative to the completion semantics negation as failure can also be interpreted epistemically as in the stable model semantics of answer set programming in this interpretation not b i means literally that b i is not known or not believed the epistemic interpretation has the advantage that it can be combined very simply with classical negation as in extended logic programming to formalise such phrases as the contrary can not be shown where contrary is classical negation and can not be shown is the epistemic interpretation of negation as failure edit problem solving in the simplified propositional case in which a logic program and a top level atomic goal contain no variables backward reasoning determines an and or tree which constitutes the search space for solving the goal the top level goal is the root of the tree given any node in the tree and any clause whose head matches the node there exists a set of child nodes corresponding to the sub goals in the body of the clause these child nodes are grouped together by an and the alternative sets of children corresponding to alternative ways of solving the node are grouped together by an or any search strategy can be used to search this space prolog uses a sequential last in first out backtracking strategy in which only one alternative and one sub goal is considered at a time other search strategies such as parallel search intelligent backtracking or best first search to find an optimal solution are also possible in the more general case where sub goals share variables other strategies can be used such as choosing the subgoal that is most highly instantiated or that is sufficiently instantiated so that only one procedure applies such strategies are used for example in concurrent logic programming the fact that there are alternative ways of executing a logic program has been characterised by the equation algorithm logic control where logic represents a logic program and control represents different theorem proving strategies 1 edit knowledge representation the fact that horn clauses can be given a procedural interpretation and vice versa that goal reduction procedures can be understood as horn clauses backward reasoning means that logic programs combine declarative and procedural representations of knowledge the inclusion of negation as failure means that logic programming is a kind of non monotonic logic despite its simplicity compared with classical logic this combination of horn clauses and negation as failure has proved to be surprisingly expressive for example it has been shown to correspond with some further extensions quite naturally to the semi formal language of legislation it is also a natural language for expressing common sense laws of cause and effect as in the situation calculus and event calculus edit abductive logic programming abductive logic programming is an extension of normal logic programming that allows some predicates declared as abducible predicates to be incompletely defined problem solving is achieved by deriving hypotheses expressed in terms of the abducible predicates as solutions of problems to be solved these problems can be either observations that need to be explained as in classical abductive reasoning or goals to be achieved as in normal logic programming it has been used to solve problems in diagnosis planning natural language and machine learning it has also been used to interpret negation as failure as a form of abductive reasoning edit metalogic programming because mathematical logic has a long tradition of distinguishing between object language and metalanguage logic programming also allows metalevel programming the simplest metalogic program is the so called vanilla meta interpreter solve true solve a b solve a solve b solve a clause a b solve b where true represents an empty conjunction and clause a b means there is an object level clause of the form a 160 b metalogic programming allows object level and metalevel representations to be combined as in natural language it can also be used to implement any logic that is specified by means of inference rules edit constraint logic programming constraint logic programming is an extension of normal logic programming that allows some predicates declared as constraint predicates to occur as literals in the body of clauses these literals are not solved by goal reduction using program clauses but are added to a store of constraints which is required to be consistent with some built in semantics of the constraint predicates problem solving is achieved by reducing the initial problem to a satisfiable set of constraints constraint logic programming has been used to solve problems in such fields as civil engineering mechanical engineering digital circuit verification automated timetabling air traffic control and finance it is closely related to abductive logic programming edit concurrent logic programming keith clark steve gregory vijay saraswat udi shapiro kazunori ueda etc developed a family of prolog like concurrent message passing systems using unification of shared variables and data structure streams for messages efforts were made to base these systems on mathematical logic and they were used as the basis of the japanese fifth generation project icot however the prolog like concurrent systems were based on message passing and consequently were subject to the same indeterminacy as other concurrent message passing systems such as actors see indeterminacy in concurrent computation consequently the icot languages were not based on logic in the sense that computational steps could not be logically deduced hewitt and agha 1988 concurrent constraint logic programming combines concurrent logic programming and constraint logic programming using constraints to control concurrency a clause can contain a guard which is a set of constraints that may block the applicability of the clause when the guards of several clauses are satisfied concurrent constraint logic programming makes a committed choice to the use of only one edit inductive logic programming main article inductive logic programming inductive logic programming is concerned with generalizing positive and negative examples in the context of background knowledge generalizations as well as the examples and background knowledge are expressed in logic programming syntax recent work in this area combining logic programming learning and probability has given rise to the new field of statistical relational learning and probabilistic inductive logic programming edit higher order logic programming several researchers have extended logic programming with higher order programming features derived from higher order logic such as predicate variables such languages include the prolog extensions hilog and prolog edit linear logic programming basing logic programming within linear logic has resulted in the design of logic programming languages that are considerably more expressive than those based on classical logic horn clause programs can only represent state change by the change in arguments to predicates in linear logic programming one can use the ambient linear logic to support state change some early designs of logic programming languages based on linear logic include lo andreoli amp pareschi 1991 lolli hodas amp miller 1994 acl kobayashi amp yonezawa 1994 and forum miller 1996 forum provides a goal directed interpretation of all of linear logic edit see also boolean satisfiability problem constraint logic programming datalog functional programming inductive logic programming fuzzy logic logic in computer science includes formal methods logic programming languages programming paradigm r satisfiability edit references this article includes a list of references but its sources remain unclear because it has insufficient inline citations please help to improve this article by introducing more precise citations february 2012 r a kowalski july 1979 algorithm logic control communications of the acm 22 7 424 436 edit general introductions chitta baral and michael gelfond logic programming and knowledge representation journal of logic programming 1994 vol 19 73 148 robert kowalski the early years of logic programming cacm january 1988 j w lloyd foundations of logic programming 2nd edition springer verlag 1987 edit other sources fisher black a deductive question answering system harvard university thesis 1964 j m foster and e w elcock absys 1 an incremental compiler for assertions an introduction machine intelligence 4 edinburgh u press 1969 pp 160 423 429 cordell green application of theorem proving to problem solving ijcai 1969 pat hayes computation and deduction in proceedings of the 2nd mfcs symposium czechoslovak academy of sciences 1973 pp 160 105 118 carl hewitt planner a language for proving theorems in robots ijcai 1969 joshua hodas and dale miller logic programming in a fragment of intuitionistic linear logic information and computation 1994 110 2 327 365 naoki kobayashi and akinori yonezawa asynchronous communication model based on linear logic formal aspects of computing 1994 279 294 robert kowalski and donald and kuehner linear resolution with selection function artificial intelligence vol 2 1971 pp 160 227 60 robert kowalski predicate logic as a programming language memo 70 department of artificial intelligence edinburgh university 1973 also in proceedings ifip congress stockholm north holland publishing co 1974 pp 160 569 574 john mccarthy programs with common sense symposium on mechanization of thought processes national physical laboratory teddington england 1958 d miller g nadathur f pfenning a scedrov uniform proofs as a foundation for logic programming annals of pure and applied logic vol 51 pp 125 157 1991 ehud shapiro editor concurrent prolog mit press 1987 ehud shapiro the family of concurrent logic programming languages acm computing surveys september 1989 james slagle experiments with a deductive question answering program cacm december 1965 shunichi uchida and kazuhiro fuchi proceedings of the fgcs project evaluation workshop institute for new generation computer technology icot 1992 edit further reading carl hewitt procedural embedding of knowledge in planner ijcai 1971 carl hewitt the repeated demise of logic programming and why it will be reincarnated what went wrong and why lessons from ai research and applications technical report ss 06 08 aaai press march 2006 evgeny dantsin thomas eiter georg gottlob andrei voronkov complexity and expressive power of logic programming acm comput surv 33 3 374 425 2001 ulf nilsson and jan maluszynski logic programming and prolog edit external links logic programming virtual library entry bibliographies on logic programming association for logic programming alp theory and practice of logic programming journal logic programming in c with castor logic programming in oz prolog development center racklog logic programming in racket v t e types of programming languages array aspect oriented assembly class based compiled concatenative concurrent data structured dataflow declarative domain specific dynamic esoteric event driven extensible functional high level imperative interpreted logic low level machine macro metaprogramming multi paradigm non english based object based object oriented off side rule pipeline procedural prototype based reflective rule based scripting synchronous very high level visual v t e computable knowledge topics and concepts alphabet of human thought automated reasoning commonsense knowledge base commonsense reasoning computability formal system inference engine knowledge base knowledge based systems knowledge discovery knowledge engineering knowledge representation knowledge retrieval knowledge extraction logic programming ontology question answering semantic reasoner proposals and implementations zairja ars magna ramon llull 1300 an essay towards a real character and a philosophical language john wilkins 1688 calculus ratiocinator amp characteristica universalis gottfried leibniz 1700 dewey decimal classification melvil dewey 1876 begriffsschrift gottlob frege 1879 mundaneum paul otlet amp henri la fontaine 1910 logical atomism bertrand russell 1918 tractatus logico philosophicus ludwig wittgenstein 1921 hilbert s program david hilbert 1920s incompleteness theorem kurt g del 1931 memex vannevar bush 1945 prolog 1972 cyc 1984 true knowledge true knowledge ltd 2007 wolfram alpha wolfram research 2009 watson ibm 2011 siri apple 2011 knowledge graph google 2012 in fiction the engine gulliver s travels 1726 joe a logic named joe 1946 the librarian snow crash 1992 dr know a i artificial intelligence 2001 waterhouse the baroque cycle 2003 see also logic machines in fiction and list of fictional computers 