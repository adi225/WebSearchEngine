in complexity theory and computability theory an oracle machine is an abstract machine used to study decision problems it can be visualized as a turing machine with a black box called an oracle which is able to decide certain decision problems in a single operation the problem can be of any complexity class even undecidable problems like the halting problem can be used contents 1 oracles 2 definitions 2 1 alternative definitions 3 complexity classes of oracle machines 4 oracles and halting problems 5 applications to cryptography 6 see also 7 references edit oracles an oracle machine can be conceived as a turing machine connected to an oracle the oracle in this context is an entity capable of solving some problem which for example may be a decision problem or a function problem the problem may not be computable the oracle is not assumed to be a turing machine or computer program the oracle is simply a black box that is able to produce a solution for any instance of a given computational problem a decision problem is represented as a set a of natural numbers or strings an instance of the problem is an arbitrary natural number or string the solution to the instance is yes if the number string is in the set and no otherwise a function problem is represented by a function f from natural numbers or strings to natural numbers or strings an instance of the problem is an input x for f the solution is the value f x an oracle machine can perform all of the usual operations of a turing machine and can also query the oracle to obtain a solution to any instance of the computational problem for that oracle for example if the problem is a decision problem for a set a of natural numbers the oracle machine will supply the oracle with a natural number and the oracle with respond with yes or no to say whether that number is an element of a edit definitions there are many equivalent definitions of oracle turing machines as discussed below the one presented here is from van melkebeek 2000 43 an oracle machine like a turing machine includes a work tape a sequence of cells without beginning or end each of which may contain a b for blank or a symbol from the tape alphabet a read write head which rests on a single cell of the work tape and can read the data there write new data and move left or right along the tape a control mechanism which can be in one of a finite number of states and which will perform different actions reading data writing data moving the control mechanism and changing states depending on the current state and the data being read in addition to these components an oracle machine also includes an oracle tape which is a semi infinite tape separate from the work tape the alphabet for the oracle tape may be different than the alphabet for the work tape an oracle head which like the read write head can move left or right along the oracle tape reading and writing symbols two special states the ask state and the response state from time to time the oracle machine may enter the ask state when this happens the following actions are performed in a single computational step the contents of the query tape are viewed as an instance of the oracle s computational problem the oracle is consulted and the contents of the query tape are replaced with the solution to that instance of the problem the oracle head is moved to the first square on the oracle tape the state of the oracle machine is changed to response the effect of changing to the ask state is thus to receive in a single step a solution to the problem instance that is written on the oracle tape edit alternative definitions there are many alternative definitions to the one presented above many of these are specialized for the case where the oracle solves a decision problem in this case some definitions instead of writing the answer to the oracle tape have two special states yes and no in addition to the ask state when the oracle is consulted the next state is chosen to be yes if the contents of the oracle tape are in the oracle set and chosen to the no if the contents are not in the oracle set adachi 1990 111 some definitions eschew the separate oracle tape when the oracle state is entered a tape symbol is specified the oracle is queried with the number of times that this tape symbol appears on the work tape if that number is in the oracle set the next state is the yes state if it is not the next state is the no state rogers 1967 129 another alternative definition makes the oracle tape read only and eliminates the ask and response states entirely before the machine is started the indicator function of the oracle set is written on the oracle tape using symbols 0 and 1 the machine is then able to query the oracle by scanning to the correct square on the oracle tape and reading the value located there soare 1987 47 rogers 1967 130 these definitions are equivalent from the point of view of turing computability a function is oracle computable from a given oracle under all of these definitions if it is oracle computable under any of them the definitions are not equivalent however from the point of view of computational complexity a definition such as the one by van melkebeek using an oracle tape which may have its own alphabet is required in general edit complexity classes of oracle machines the complexity class of decision problems solvable by an algorithm in class a with an oracle for a language l is called a l for example p sat is the class of problems solvable in polynomial time by a deterministic turing machine with an oracle for the boolean satisfiability problem the notation a b can be extended to a set of languages b or a complexity class b by using the following definition when a language l is complete for some class b then a l a b provided that machines in a can execute reductions used in the completeness definition of class b in particular since sat is np complete with respect to polynomial time reductions p sat p np however if a dlogtime then a sat may not equal a np it is obvious that np p np but the question of whether np np p np np and p are equal remains tentative at best it is believed they are different and this leads to the definition of the polynomial hierarchy oracle machines are useful for investigating the relationship between complexity classes p and np by considering the relationship between p a and np a for an oracle a in particular it has been shown there exist languages a and b such that p a np a and p b np b baker gill and solovay 1975 the fact the p np question relativizes both ways is taken as evidence that answering this question is difficult because a proof technique that relativizes i e unaffected by the addition of an oracle will not answer the p np question most proof techniques relativize it is interesting to consider the case where an oracle is chosen randomly from among all possible oracles an infinite set it has been shown in this case then with probability 1 p a np a bennet and gill 1981 when a question is true for almost all oracles it is said to be true for a random oracle this choice of terminology is justified by the fact random oracles support a statement with probability 0 or 1 only this follows from kolmogorov s zero one law this is taken as evidence p np a statement may be true for a random oracle and false for ordinary turing machines at the same time for example for oracles a ip a pspace a while ip pspace chang et al 1994 edit oracles and halting problems it is possible to posit the existence of an oracle which computes a non computable function such as the answer to the halting problem or some equivalent a machine with an oracle of this sort is a hypercomputer interestingly the halting paradox still applies to such machines although they determine whether particular turing machines will halt on particular inputs they cannot determine in general if machines equivalent to themselves will halt this fact creates a hierarchy of machines called the arithmetical hierarchy each with a more powerful halting oracle and an even harder halting problem edit applications to cryptography main article random oracle in cryptography oracles are used to make arguments for the security of cryptographic protocols where a hash function is used a security reduction for the protocol is given in the case where instead of a hash function a random oracle answers each query randomly but consistently the oracle is assumed to be available to all parties including the attacker as the hash function is such a proof shows that unless the attacker solves the hard problem at the heart of the security reduction they must make use of some interesting property of the hash function to break the protocol they cannot treat the hash function as a black box i e as a random oracle edit see also turing machine turing reduction interactive proof system matroid oracle edit references akeo adachi foundations of computation theory ohmsha 1990 t p baker j gill r solovay relativizations of the p np question siam journal on computing 4 4 431 442 1975 c h bennett j gill relative to a random oracle a p a 160 np a 160 co np a with probability 1 siam journal on computing 10 1 96 113 1981 richard chang benny chor oded goldreich juris hartmanis johan hastad desh ranjan pankaj rohatgi the random oracle hypothesis is false journal of computer and system sciences volume 49 issue 1 pp 24 39 august 1994 issn 0022 0000 http citeseer ist psu edu 282397 html lt ref gt martin davis editor the undecidable basic papers on undecidable propositions unsolvable problems and computable functions raven press new york 1965 turing s paper is in this volume papers include those by godel church rosser kleene and post c papadimitriou computational complexity addison wesley 1994 section 14 3 oracles pp 339 343 hartley rogers jr theory of recursive functions and effective computability mcgraw hill 1967 michael sipser introduction to the theory of computation pws publishing 1997 isbn 0 534 94728 x section 9 2 relativization pp 318 321 robert i soare recursively enumerable sets and degrees perspectives in mathematical logic springer 1987 alan turing systems of logic based on ordinals proc london math soc 45 1939 dieter van melkebeek randomness and completeness in computational complexity lecture notes in computer science 1950 springer 2000 