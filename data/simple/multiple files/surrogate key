this article includes a list of references related reading or external links but its sources remain unclear because it lacks inline citations please improve this article by introducing more precise citations july 2009 a surrogate key in a database is a unique identifier for either an entity in the modeled world or an object in the database the surrogate key is not derived from application data contents 1 definition 2 surrogates in practice 3 advantages 3 1 immutability 3 2 requirement changes 3 3 performance 3 4 compatibility 3 5 uniformity 3 6 validation 4 disadvantages 4 1 disassociation 4 2 query optimization 4 3 normalization 4 4 business process modeling 4 5 inadvertent disclosure 4 6 inadvertent assumptions 5 see also 6 references edit definition there are at least two definitions of a surrogate surrogate 1 hall owlett and codd 1976 a surrogate represents an entity in the outside world the surrogate is internally generated by the system but is nevertheless visible to the user or application surrogate 2 wieringa and de jonge 1991 a surrogate represents an object in the database itself the surrogate is internally generated by the system and is invisible to the user or application the surrogate 1 definition relates to a data model rather than a storage model and is used throughout this article see date 1998 an important distinction between a surrogate and a primary key depends on whether the database is a current database or a temporal database since a current database stores only currently valid data there is a one to one correspondence between a surrogate in the modeled world and the primary key of the database in this case the surrogate may be used as a primary key resulting in the term surrogate key in a temporal database however there is a many to one relationship between primary keys and the surrogate since there may be several objects in the database corresponding to a single surrogate we cannot use the surrogate as a primary key another attribute is required in addition to the surrogate to uniquely identify each object although hall et al 1976 say nothing about this others specify have argued that a surrogate should have the following characteristics the value is unique system wide hence never reused the value is system generated the value is not manipulable by the user or application the value contains no semantic meaning the value is not visible to the user or application the value is not composed of several values from different domains edit surrogates in practice in a current database the surrogate key can be the primary key generated by the database management system and not derived from any application data in the database the only significance of the surrogate key is to act as the primary key it is also possible that the surrogate key exists in addition to the database generated uuid for example an hr number for each employee other than the uuid of each employee a surrogate key is frequently a sequential number e g a sybase or sql server identity column a postgresql or informix serial an oracle sequence or a column defined with auto increment in mysql but doesn t have to be having the key independent of all other columns insulates the database relationships from changes in data values or database design making the database more agile and guarantees uniqueness in a temporal database it is necessary to distinguish between the surrogate key and the primary key typically every row would have both a primary key and a surrogate key the primary key identifies the unique row in the database the surrogate key identifies the unique entity in the modelled world these two keys are not the same for example table staff may contain two rows for john smith one row when he was employed between 1990 and 1999 another row when he was employed between 2001 and 2006 the surrogate key is identical non unique in both rows however the primary key will be unique some database designers use surrogate keys systematically regardless of the suitability of other candidate keys while others will use a key already present in the data if there is one a surrogate key may also be called a synthetic key an entity identifier a system generated key a database sequence number a factless key a technical key or an arbitrary unique identifier citation needed some of these terms describe the way of generating new surrogate values rather than the nature of the surrogate concept approaches to generating surrogates include universally unique identifiers uuids globally unique identifiers guids object identifiers oids sybase or sql server identity column identity or identity n n oracle sequence postgresql or ibm informix serial mysql auto increment autonumber data type in microsoft access as identity generated by default in ibm db2 identity column implemented in ddl in teradata edit advantages edit immutability surrogate keys do not change while the row exists this has the following advantages applications cannot lose their reference to a row in the database since the identifier never changes the primary key data can always be modified even with databases that do not support cascading updates across related foreign keys edit requirement changes attributes that uniquely identify an entity might change which might invalidate the suitability of the natural compound keys consider the following example an employee s network user name is chosen as a natural key upon merging with another company new employees must be inserted some of the new network user names create conflicts because their user names were generated independently when the companies were separate in these cases generally a new attribute must be added to the natural key for example an original company column with a surrogate key only the table that defines the surrogate key must be changed with natural keys all tables and possibly other related software that use the natural key will have to change some problem domains do not clearly identify a suitable natural key surrogate key avoids choosing a natural key that might be incorrect edit performance surrogate keys tend to be a compact data type such as a four byte integer this allows the database to query the single key column faster than it could multiple columns furthermore a non redundant distribution of keys causes the resulting b tree index to be completely balanced surrogate keys are also less expensive to join fewer columns to compare than compound keys edit compatibility while using several database application development systems drivers and object relational mapping systems such as ruby on rails or hibernate it is much easier to use an integer or guid surrogate keys for every table instead of natural keys in order to support database system agnostic operations and object to row mapping edit uniformity when every table has a uniform surrogate key some tasks can be easily automated by writing the code in a table independent way edit validation it is possible to design key values that follow a well known pattern or structure which can be automatically verified for instance the keys that are intended to be used in some column of some table might be designed to look differently from those that are intended to be used in another column or table thereby simplifying the detection of application errors in which the keys have been misplaced however this characteristic of the surrogate keys should never be used to drive any of the logic of the applications themselves as this would violate the principles of database normalization edit disadvantages edit disassociation the values of generated surrogate keys have no relationship to the real world meaning of the data held in a row when inspecting a row holding a foreign key reference to another table using a surrogate key the meaning of the surrogate key s row cannot be discerned from the key itself every foreign key must be joined to see the related data item this can also make auditing more difficult citation needed as incorrect data is not obvious surrogate keys are unnatural for data that is exported and shared a particular difficulty is that tables from two otherwise identical schemas for example a test schema and a development schema can hold records that are equivalent in a business sense but have different keys this can be mitigated by not exporting surrogate keys except as transient data most obviously in executing applications that have a live connection to the database edit query optimization relational databases assume a unique index is applied to a table s primary key the unique index serves two purposes i to enforce entity integrity since primary key data must be unique across rows and ii to quickly search for rows when queried since surrogate keys replace a table s identifying attributes the natural key and since the identifying attributes are likely to be those queried then the query optimizer is forced to perform a full table scan when fulfilling likely queries the remedy to the full table scan is to apply indexes on the identifying attributes or sets of them where such sets are themselves a candidate key the index can be a unique index these additional indexes however will take up disk space and slow down inserts and deletes edit normalization the presence of a surrogate key can result in the database administrator forgetting to establish or accidentally removing a secondary unique index on the natural key of the table without a unique index on the natural key duplicate rows can appear and once present can be difficult to identify edit business process modeling because surrogate keys are unnatural flaws can appear when modeling the business requirements business requirements relying on the natural key then need to be translated to the surrogate key a strategy is to draw a clear distinction between the logical model in which surrogate keys do not appear and the physical implementation of that model to ensure that the logical model is correct and reasonably well normalised and to ensure that the physical model is a correct implementation of the logical model edit inadvertent disclosure proprietary information can be leaked if sequential key generators are used by subtracting a previously generated sequential key from a recently generated sequential key one could learn the number of rows inserted during that time period this could expose for example the number of transactions or new accounts per period there are a few ways to overcome this problem increase the sequential number by a random amount generate a completely random primary key however to prevent duplication which would cause an insert rejection a randomly generated primary key must either be queried to check that it is not already in use or the key must contain enough entropy that one can be confident that collisions will not happen edit inadvertent assumptions sequentially generated surrogate keys create the illusion that events with a higher primary key value occurred after events with a lower primary key value this illusion would appear when an event is missed during the normal data entry process and is instead inserted after subsequent events were previously inserted the solution to the inadvertent assumption problem is to generate a random primary key however a randomly generated primary key must be queried before assigned to prevent duplication and cause an insert rejection citation needed edit see also natural key object identifier persistent object identifier edit references this article is based on material taken from the free on line dictionary of computing prior to 1 november 2008 and incorporated under the relicensing terms of the gfdl version 1 3 or later nijssen g m 1976 modelling in data base management systems north holland pub co isbn 160 0 7204 0459 2 engles r w 1972 a tutorial on data base organization annual review in automatic programming vol 7 part 1 pergamon press oxford pp 160 1 64 langefors b 1968 elementary files and elementary file records proceedings of file 68 an ifip iag international seminar on file organisation amsterdam november pp 160 89 96 wieringa r de jonge w 1991 the identification of objects and roles object identifiers revisited citeseerx 10 1 1 16 3195 date c j 1998 chapters 11 and 12 relational database writings 1994 1997 asin 160 0201398141 carter breck intelligent versus surrogate keys http www bcarter com intsurr1 htm retrieved 2006 12 03 richardson lee create data disaster avoid unique indexes mistake 3 of 10 http www nearinfinity com blogs page lrichard entry create data disaster avoid unique retrieved 2008 01 19 berkus josh database soup primary keyvil part i http blogs ittoolbox com database soup archives primary keyvil part i 7327 retrieved 2006 12 03 v t e database management systems database models database normalization database storage distributed dbms federated database system referential integrity relational algebra relational calculus relational database relational dbms relational model object relational database transaction processing concepts database acid crud null candidate key foreign key primary key superkey surrogate key armstrong s axioms objects relation table column row view transaction log trigger index stored procedure cursor partition components concurrency control data dictionary jdbc xqj odbc query language query optimizer query plan functions administration and automation query optimization replication database products object oriented comparison relational comparison document oriented nosql newsql 