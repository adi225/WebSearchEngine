an example formal specification using the z notation in computer science specifically software engineering and hardware engineering formal methods are a particular kind of mathematically based techniques for the specification development and verification of software and hardware systems 1 the use of formal methods for software and hardware design is motivated by the expectation that as in other engineering disciplines performing appropriate mathematical analysis can contribute to the reliability and robustness of a design 2 formal methods are best described as the application of a fairly broad variety of theoretical computer science fundamentals in particular logic calculi formal languages automata theory and program semantics but also type systems and algebraic data types to problems in software and hardware specification and verification 3 contents 1 taxonomy 1 1 lightweight formal methods 2 uses 2 1 specification 2 2 development 2 3 verification 2 3 1 human directed proof 2 3 2 automated proof 3 criticisms 4 formal methods and notations 5 see also 6 references 7 further reading 8 external links edit taxonomy formal methods can be used at a number of levels level 0 formal specification may be undertaken and then a program developed from this informally this has been dubbed formal methods lite this may be the most cost effective option in many cases level 1 formal development and formal verification may be used to produce a program in a more formal manner for example proofs of properties or refinement from the specification to a program may be undertaken this may be most appropriate in high integrity systems involving safety or security level 2 theorem provers may be used to undertake fully formal machine checked proofs this can be very expensive and is only practically worthwhile if the cost of mistakes is extremely high e g in critical parts of microprocessor design further information on this is expanded below as with programming language semantics styles of formal methods may be roughly classified as follows denotational semantics in which the meaning of a system is expressed in the mathematical theory of domains proponents of such methods rely on the well understood nature of domains to give meaning to the system critics point out that not every system may be intuitively or naturally viewed as a function operational semantics in which the meaning of a system is expressed as a sequence of actions of a presumably simpler computational model proponents of such methods point to the simplicity of their models as a means to expressive clarity critics counter that the problem of semantics has just been delayed who defines the semantics of the simpler model axiomatic semantics in which the meaning of the system is expressed in terms of preconditions and postconditions which are true before and after the system performs a task respectively proponents note the connection to classical logic critics note that such semantics never really describe what a system does merely what is true before and afterwards edit lightweight formal methods some practitioners believe that the formal methods community has overemphasized full formalization of a specification or design 4 5 they contend that the expressiveness of the languages involved as well as the complexity of the systems being modelled make full formalization a difficult and expensive task as an alternative various lightweight formal methods which emphasize partial specification and focused application have been proposed examples of this lightweight approach to formal methods include the alloy object modelling notation 6 denney s synthesis of some aspects of the z notation with use case driven development 7 and the csk vdm tools 8 edit uses formal methods can be applied at various points through the development process edit specification formal methods may be used to give a description of the system to be developed at whatever level s of detail desired this formal description can be used to guide further development activities see following sections additionally it can be used to verify that the requirements for the system being developed have been completely and accurately specified the need for formal specification systems has been noted for years in the algol 58 report 9 john backus presented a formal notation for describing programming language syntax later named backus normal form then renamed backus naur form bnf 10 backus also wrote that a formal description of the meaning of syntactically valid algol programs wasn t completed in time for inclusion in the report therefore the formal treatment of the semantics of legal programs will be included in a subsequent paper it never appeared edit development once a formal specification has been produced the specification may be used as a guide while the concrete system is developed during the design process i e realized typically in software but also potentially in hardware for example if the formal specification is in an operational semantics the observed behavior of the concrete system can be compared with the behavior of the specification which itself should be executable or simulateable additionally the operational commands of the specification may be amenable to direct translation into executable code if the formal specification is in an axiomatic semantics the preconditions and postconditions of the specification may become assertions in the executable code edit verification once a formal specification has been developed the specification may be used as the basis for proving properties of the specification and hopefully by inference the developed system edit human directed proof sometimes the motivation for proving the correctness of a system is not the obvious need for re assurance of the correctness of the system but a desire to understand the system better consequently some proofs of correctness are produced in the style of mathematical proof handwritten or typeset using natural language using a level of informality common to such proofs a good proof is one which is readable and understandable by other human readers critics of such approaches point out that the ambiguity inherent in natural language allows errors to be undetected in such proofs often subtle errors can be present in the low level details typically overlooked by such proofs additionally the work involved in producing such a good proof requires a high level of mathematical sophistication and expertise edit automated proof in contrast there is increasing interest in producing proofs of correctness of such systems by automated means automated techniques fall into two general categories automated theorem proving in which a system attempts to produce a formal proof from scratch given a description of the system a set of logical axioms and a set of inference rules model checking in which a system verifies certain properties by means of an exhaustive search of all possible states that a system could enter during its execution some automated theorem provers require guidance as to which properties are interesting enough to pursue while others work without human intervention model checkers can quickly get bogged down in checking millions of uninteresting states if not given a sufficiently abstract model proponents of such systems argue that the results have greater mathematical certainty than human produced proofs since all the tedious details have been algorithmically verified the training required to use such systems is also less than that required to produce good mathematical proofs by hand making the techniques accessible to a wider variety of practitioners critics note that some of those systems are like oracles they make a pronouncement of truth yet give no explanation of that truth there is also the problem of verifying the verifier if the program which aids in the verification is itself unproven there may be reason to doubt the soundness of the produced results some modern model checking tools produce a proof log detailing each step in their proof making it possible to perform given suitable tools independent verification edit criticisms the field of formal methods has its critics citation needed handwritten proofs of correctness need significant time and thus money to produce with limited utility other than assuring correctness this makes formal methods more likely to be used in fields where it is possible to perform automated proofs using software or in cases where the cost of a fault is high example in railway engineering and aerospace engineering undetected errors may cause death so formal methods are more popular in this field than in other application areas edit formal methods and notations this section is in a list format that may be better presented using prose you can help by converting this section to prose if appropriate editing help is available august 2009 there are a variety of formal methods and notations available specification languages abstract state machines asms ansi iso c specification language acsl alloy autonomic system specification language assl b method cadp common algebraic specification language casl process calculi csp lotos calculus actor model esterel lustre mcrl2 perfect developer petri nets raise spark ada specification and description language temporal logic of actions tla usl vdm vdm sl vdm z notation rebeca modeling language model checkers spin pat is a powerful free model checker simulator and refinement checker for concurrent systems and csp extensions e g shared variables arrays fairness malpas software static analysis toolset is an industrial strength model checker used for formal proof of safety critical systems edit see also automated theorem proving design by contract formal methods people formal specification formal verification formal system model checking software engineering specification language edit references r w butler 2001 08 06 what is formal methods http shemesh larc nasa gov fm fm what html retrieved 2006 11 16 c michael holloway why engineers should consider formal methods 16th digital avionics systems conference 27 30 october 1997 http klabs org richcontent verification holloway nasa 97 16dasc cmh pdf retrieved 2006 11 16 monin pp 3 4 daniel jackson and jeannette wing lightweight formal methods ieee computer april 1996 vinu george and rayford vaughn application of lightweight formal methods in requirement engineering crosstalk the journal of defense software engineering january 2003 daniel jackson alloy a lightweight object modelling notation acm transactions on software engineering and methodology tosem volume 11 issue 2 april 2002 pp 256 290 richard denney succeeding with use cases working smart to deliver quality addison wesley professional publishing 2005 isbn 0 321 31643 6 sten agerholm and peter g larsen a lightweight approach to formal methods in proceedings of the international workshop on current trends in applied formal methods boppard germany springer verlag october 1998 backus j w 1959 the syntax and semantics of the proposed international algebraic language of z rich acm gamm conference proceedings of the international conference on information processing unesco knuth donald e 1964 backus normal form vs backus naur form communications of the acm 7 12 735 736 this article is based on material taken from the free on line dictionary of computing prior to 1 november 2008 and incorporated under the relicensing terms of the gfdl version 1 3 or later edit further reading jean fran ois monin and michael g hinchey understanding formal methods springer 2003 isbn 1 85233 247 6 jonathan p bowen and michael g hinchey formal methods in allen b tucker jr ed computer science handbook 2nd edition section xi software engineering chapter 106 pages 106 1 160 106 25 chapman amp hall crc press association for computing machinery 2004 michael g hinchey jonathan p bowen and emil vassev formal methods in philip a laplante ed encyclopedia of software engineering taylor amp francis 2010 pages 308 320 edit external links formal methods europe fme formal method keyword on microsoft academic search foldoc formal methods evidence on formal methods uses and impact on industry supported by the deploy project eu fp7 v t e major fields of computer science mathematical foundations mathematical logic set theory number theory graph theory type theory category theory numerical analysis information theory combinatorics boolean algebra theory of computation automata theory computability theory computational complexity theory quantum computing theory algorithms data structures analysis of algorithms algorithm design computational geometry programming languages compilers parsers interpreters procedural programming object oriented programming functional programming logic programming programming paradigms concurrent parallel distributed systems multiprocessing grid computing concurrency control software engineering requirements analysis software design computer programming formal methods software testing software development process system architecture computer architecture computer organization operating systems telecommunication networking computer audio routing network topology cryptography databases database management systems relational databases sql transactions database indexes data mining artificial intelligence automated reasoning computational linguistics computer vision evolutionary computation expert systems machine learning natural language processing robotics computer graphics visualization computer animation image processing human computer interaction computer accessibility user interfaces wearable computing ubiquitous computing virtual reality scientific computing artificial life bioinformatics cognitive science computational chemistry computational neuroscience computational physics numerical algorithms symbolic mathematics note computer science can also be divided into different topics or fields according to the acm computing classification system v t e software engineering fields computer programming formal methods requirements analysis software deployment software design software maintenance software testing systems analysis concepts data modeling enterprise architecture functional specification modeling language orthogonality programming paradigm software software architecture software development methodology software development process software quality software quality assurance software archaeology structured analysis orientations agile aspect oriented object orientation ontology service orientation sdlc models developmental agile eup executable uml incremental model iterative model rup scrum prototype model spiral model v model waterfall model xp other spice cmmi data model er model function model information model metamodeling object model systems model view model languages idef uml sysml software engineers kent beck grady booch fred brooks barry boehm peter chen ward cunningham ole johan dahl tom demarco martin fowler c a r hoare watts humphrey michael a jackson ivar jacobson james martin stephen j mellor bertrand meyer david parnas winston w royce james rumbaugh niklaus wirth edward yourdon victor basili related fields computer science computer engineering enterprise engineering history management project management quality management software ergonomics systems engineering category commons 