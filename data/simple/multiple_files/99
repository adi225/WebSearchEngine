this article is about the computing term for the anime see compiler anime a diagram of the operation of a typical multi language multi target compiler a compiler is a computer program or set of programs that transforms source code written in a programming language the source language into another computer language the target language often having a binary form known as object code the most common reason for wanting to transform source code is to create an executable program the name compiler is primarily used for programs that translate source code from a high level programming language to a lower level language e g assembly language or machine code if the compiled program can run on a computer whose cpu or operating system is different from the one on which the compiler runs the compiler is known as a cross compiler a program that translates from a low level language to a higher level one is a decompiler a program that translates between high level languages is usually called a language translator source to source translator or language converter a language rewriter is usually a program that translates the form of expressions without a change of language a compiler is likely to perform many or all of the following operations lexical analysis preprocessing parsing semantic analysis syntax directed translation code generation and code optimization program faults caused by incorrect compiler behavior can be very difficult to track down and work around therefore compiler implementors invest significant effort to ensure the correctness of their software the term compiler compiler is sometimes used to refer to a parser generator a tool often used to help create the lexer and parser contents 1 history 1 1 compilers in education 2 compilation 2 1 structure of a compiler 3 compiler output 3 1 compiled versus interpreted languages 3 2 hardware compilation 4 compiler construction 4 1 one pass versus multi pass compilers 4 2 front end 4 3 back end 5 compiler correctness 6 related techniques 7 international conferences and organizations 8 see also 9 notes 10 references 11 external links edit history main article history of compiler construction software for early computers was primarily written in assembly language higher level programming languages were not invented until the benefits of being able to reuse software on different kinds of cpus started to become significantly greater than the costs of writing a compiler the limited memory capacity of early computers led to substantial technical challenges when designing the first compilers towards the end of the 1950s machine independent programming languages were first proposed subsequently several experimental compilers were developed the first compiler was written by grace hopper in 1952 for the a 0 programming language the fortran team led by john backus at ibm is generally credited as having introduced the first complete compiler in 1957 cobol was an early language to be compiled on multiple architectures in 1960 1 in many application domains the idea of using a higher level language quickly caught on because of the expanding functionality supported by newer programming languages and the increasing complexity of computer architectures compilers have become more complex early compilers were written in assembly language the first self hosting compiler capable of compiling its own source code in a high level language was created in 1962 for lisp by tim hart and mike levin at mit 2 since the 1970s it has become common practice to implement a compiler in the language it compiles although both pascal and c have been popular choices for implementation language building a self hosting compiler is a bootstrapping problem the first such compiler for a language must be compiled either by hand or by a compiler written in a different language or as in hart and levin s lisp compiler compiled by running the compiler in an interpreter edit compilers in education compiler construction and compiler optimization are taught at universities and schools as part of a computer science curriculum 3 such courses are usually supplemented with the implementation of a compiler for an educational programming language a well documented example is niklaus wirth s pl 0 compiler which wirth used to teach compiler construction in the 1970s 4 in spite of its simplicity the pl 0 compiler introduced several influential concepts to the field program development by stepwise refinement also the title of a 1971 paper by wirth 5 the use of a recursive descent parser the use of ebnf to specify the syntax of a language a code generator producing portable p code the use of t diagrams 6 in the formal description of the bootstrapping problem edit compilation compilers enabled the development of programs that are machine independent before the development of fortran formula translator the first higher level language in the 1950s machine dependent assembly language was widely used while assembly language produces more reusable and relocatable programs than machine code on the same architecture it has to be modified or rewritten if the program is to be executed on different computer hardware architecture with the advance of high level programming languages that followed fortran such as cobol c and basic programmers could write machine independent source programs a compiler translates the high level source programs into target programs in machine languages for the specific hardwares once the target program is generated the user can execute the program edit structure of a compiler compilers bridge source programs in high level languages with the underlying hardware a compiler requires 1 determining the correctness of the syntax of programs 2 generating correct and efficient object code 3 run time organization and 4 formatting output according to assembler and or linker conventions a compiler consists of three main parts the frontend the middle end and the backend the front end checks whether the program is correctly written in terms of the programming language syntax and semantics here legal and illegal programs are recognized errors are reported if any in a useful way type checking is also performed by collecting type information the frontend then generates an intermediate representation or ir of the source code for processing by the middle end the middle end is where optimization takes place typical transformations for optimization are removal of useless or unreachable code discovery and propagation of constant values relocation of computation to a less frequently executed place e g out of a loop or specialization of computation based on the context the middle end generates another ir for the following backend most optimization efforts are focused on this part the back end is responsible for translating the ir from the middle end into assembly code the target instruction s are chosen for each ir instruction register allocation assigns processor registers for the program variables where possible the backend utilizes the hardware by figuring out how to keep parallel execution units busy filling delay slots and so on although most algorithms for optimization are in np heuristic techniques are well developed edit compiler output one classification of compilers is by the platform on which their generated code executes this is known as the target platform a native or hosted compiler is one which output is intended to directly run on the same type of computer and operating system that the compiler itself runs on the output of a cross compiler is designed to run on a different platform cross compilers are often used when developing software for embedded systems that are not intended to support a software development environment the output of a compiler that produces code for a virtual machine vm may or may not be executed on the same platform as the compiler that produced it for this reason such compilers are not usually classified as native or cross compilers the lower level language that is the target of a compiler may itself be a high level programming language c often viewed as some sort of portable assembler can also be the target language of a compiler e g cfront the original compiler for c used c as target language the c created by such a compiler is usually not intended to be read and maintained by humans so indent style and pretty c intermediate code are irrelevant some features of c turn it into a good target language e g c code with line directives can be generated to support debugging of the original source edit compiled versus interpreted languages higher level programming languages usually appear with a type of translation in mind either designed as compiled language or interpreted language however in practice there is rarely anything about a language that requires it to be exclusively compiled or exclusively interpreted although it is possible to design languages that rely on re interpretation at run time the categorization usually reflects the most popular or widespread implementations of a language for instance basic is sometimes called an interpreted language and c a compiled one despite the existence of basic compilers and c interpreters interpretation does not replace compilation completely it only hides it from the user and makes it gradual even though an interpreter can itself be interpreted a directly executed program is needed somewhere at the bottom of the stack see machine language modern trends toward just in time compilation and bytecode interpretation at times blur the traditional categorizations of compilers and interpreters some language specifications spell out that implementations must include a compilation facility for example common lisp however there is nothing inherent in the definition of common lisp that stops it from being interpreted other languages have features that are very easy to implement in an interpreter but make writing a compiler much harder for example apl snobol4 and many scripting languages allow programs to construct arbitrary source code at runtime with regular string operations and then execute that code by passing it to a special evaluation function to implement these features in a compiled language programs must usually be shipped with a runtime library that includes a version of the compiler itself edit hardware compilation the output of some compilers may target computer hardware at a very low level for example a field programmable gate array fpga or structured application specific integrated circuit asic such compilers are said to be hardware compilers or synthesis tools because the source code they compile effectively controls the final configuration of the hardware and how it operates the output of the compilation is not instructions that are executed in sequence only an interconnection of transistors or lookup tables for example xst is the xilinx synthesis tool used for configuring fpgas similar tools are available from altera synplicity synopsys and other vendors edit compiler construction this section does not cite any references or sources please help improve this section by adding citations to reliable sources unsourced material may be challenged and removed september 2010 main article compiler construction in the early days the approach taken to compiler design used to be directly affected by the complexity of the processing the experience of the person s designing it and the resources available a compiler for a relatively simple language written by one person might be a single monolithic piece of software when the source language is large and complex and high quality output is required the design may be split into a number of relatively independent phases having separate phases means development can be parceled up into small parts and given to different people it also becomes much easier to replace a single phase by an improved one or to insert new phases later e g additional optimizations the division of the compilation processes into phases was championed by the production quality compiler compiler project pqcc at carnegie mellon university this project introduced the terms front end middle end and back end all but the smallest of compilers have more than two phases however these phases are usually regarded as being part of the front end or the back end the point at which these two ends meet is open to debate the front end is generally considered to be where syntactic and semantic processing takes place along with translation to a lower level of representation than source code the middle end is usually designed to perform optimizations on a form other than the source code or machine code this source code machine code independence is intended to enable generic optimizations to be shared between versions of the compiler supporting different languages and target processors the back end takes the output from the middle it may perform more analysis transformations and optimizations that are for a particular computer then it generates code for a particular processor and os this front end middle back end approach makes it possible to combine front ends for different languages with back ends for different cpus practical examples of this approach are the gnu compiler collection llvm and the amsterdam compiler kit which have multiple front ends shared analysis and multiple back ends edit one pass versus multi pass compilers classifying compilers by number of passes has its background in the hardware resource limitations of computers compiling involves performing lots of work and early computers did not have enough memory to contain one program that did all of this work so compilers were split up into smaller programs which each made a pass over the source or some representation of it performing some of the required analysis and translations the ability to compile in a single pass has classically been seen as a benefit because it simplifies the job of writing a compiler and one pass compilers generally perform compilations faster than multi pass compilers thus partly driven by the resource limitations of early systems many early languages were specifically designed so that they could be compiled in a single pass e g pascal in some cases the design of a language feature may require a compiler to perform more than one pass over the source for instance consider a declaration appearing on line 20 of the source which affects the translation of a statement appearing on line 10 in this case the first pass needs to gather information about declarations appearing after statements that they affect with the actual translation happening during a subsequent pass the disadvantage of compiling in a single pass is that it is not possible to perform many of the sophisticated optimizations needed to generate high quality code it can be difficult to count exactly how many passes an optimizing compiler makes for instance different phases of optimization may analyse one expression many times but only analyse another expression once splitting a compiler up into small programs is a technique used by researchers interested in producing provably correct compilers proving the correctness of a set of small programs often requires less effort than proving the correctness of a larger single equivalent program while the typical multi pass compiler outputs machine code from its final pass there are several other types a source to source compiler is a type of compiler that takes a high level language as its input and outputs a high level language for example an automatic parallelizing compiler will frequently take in a high level language program as an input and then transform the code and annotate it with parallel code annotations e g openmp or language constructs e g fortran s doall statements stage compiler that compiles to assembly language of a theoretical machine like some prolog implementations this prolog machine is also known as the warren abstract machine or wam bytecode compilers for java python and many more are also a subtype of this just in time compiler used by smalltalk and java systems and also by microsoft net s common intermediate language cil applications are delivered in bytecode which is compiled to native machine code just prior to execution edit front end the front end analyzes the source code to build an internal representation of the program called the intermediate representation or ir it also manages the symbol table a data structure mapping each symbol in the source code to associated information such as location type and scope this is done over several phases which includes some of the following line reconstruction languages which strop their keywords or allow arbitrary spaces within identifiers require a phase before parsing which converts the input character sequence to a canonical form ready for the parser the top down recursive descent table driven parsers used in the 1960s typically read the source one character at a time and did not require a separate tokenizing phase atlas autocode and imp and some implementations of algol and coral 66 are examples of stropped languages which compilers would have a line reconstruction phase lexical analysis breaks the source code text into small pieces called tokens each token is a single atomic unit of the language for instance a keyword identifier or symbol name the token syntax is typically a regular language so a finite state automaton constructed from a regular expression can be used to recognize it this phase is also called lexing or scanning and the software doing lexical analysis is called a lexical analyzer or scanner preprocessing some languages e g c require a preprocessing phase which supports macro substitution and conditional compilation typically the preprocessing phase occurs before syntactic or semantic analysis e g in the case of c the preprocessor manipulates lexical tokens rather than syntactic forms however some languages such as scheme support macro substitutions based on syntactic forms syntax analysis involves parsing the token sequence to identify the syntactic structure of the program this phase typically builds a parse tree which replaces the linear sequence of tokens with a tree structure built according to the rules of a formal grammar which define the language s syntax the parse tree is often analyzed augmented and transformed by later phases in the compiler semantic analysis is the phase in which the compiler adds semantic information to the parse tree and builds the symbol table this phase performs semantic checks such as type checking checking for type errors or object binding associating variable and function references with their definitions or definite assignment requiring all local variables to be initialized before use rejecting incorrect programs or issuing warnings semantic analysis usually requires a complete parse tree meaning that this phase logically follows the parsing phase and logically precedes the code generation phase though it is often possible to fold multiple phases into one pass over the code in a compiler implementation edit back end the term back end is sometimes confused with code generator because of the overlapped functionality of generating assembly code some literature uses middle end to distinguish the generic analysis and optimization phases in the back end from the machine dependent code generators the main phases of the back end include the following analysis this is the gathering of program information from the intermediate representation derived from the input typical analyses are data flow analysis to build use define chains dependence analysis alias analysis pointer analysis escape analysis etc accurate analysis is the basis for any compiler optimization the call graph and control flow graph are usually also built during the analysis phase optimization the intermediate language representation is transformed into functionally equivalent but faster or smaller forms popular optimizations are inline expansion dead code elimination constant propagation loop transformation register allocation and even automatic parallelization code generation the transformed intermediate language is translated into the output language usually the native machine language of the system this involves resource and storage decisions such as deciding which variables to fit into registers and memory and the selection and scheduling of appropriate machine instructions along with their associated addressing modes see also sethi ullman algorithm debug data may also need to be generated to facilitate debugging compiler analysis is the prerequisite for any compiler optimization and they tightly work together for example dependence analysis is crucial for loop transformation in addition the scope of compiler analysis and optimizations vary greatly from as small as a basic block to the procedure function level or even over the whole program interprocedural optimization obviously a compiler can potentially do a better job using a broader view but that broad view is not free large scope analysis and optimizations are very costly in terms of compilation time and memory space this is especially true for interprocedural analysis and optimizations interprocedural analysis and optimizations are common in modern commercial compilers from hp ibm sgi intel microsoft and sun microsystems the open source gcc was criticized for a long time for lacking powerful interprocedural optimizations but it is changing in this respect another open source compiler with full analysis and optimization infrastructure is open64 which is used by many organizations for research and commercial purposes due to the extra time and space needed for compiler analysis and optimizations some compilers skip them by default users have to use compilation options to explicitly tell the compiler which optimizations should be enabled edit compiler correctness main article compiler correctness compiler correctness is the branch of software engineering that deals with trying to show that a compiler behaves according to its language specification citation needed techniques include developing the compiler using formal methods and using rigorous testing often called compiler validation on an existing compiler edit related techniques assembly language is a type of low level language and a program that compiles it is more commonly known as an assembler with the inverse program known as a disassembler a program that translates from a low level language to a higher level one is a decompiler a program that translates between high level languages is usually called a language translator source to source translator language converter or language rewriter the last term is usually applied to translations that do not involve a change of language a program that translates into an object code format that is not supported on the compilation machine is called a cross compiler and is commonly used to prepare code for embedded applications edit international conferences and organizations every year the european joint conferences on theory and practice of software etaps sponsors the international conference on compiler construction cc with papers from both the academic and industrial sectors 7 edit see also book compiler construction abstract interpretation attribute grammar binary recompiler bottom up parsing byzantine fault tolerance compile and go loader compile farm compiler compiler or parser generator compiler correctness decompiler history of compiler writing just in time compilation linker list of compilers list of important publications in computer science compilers metacompilation overhead code semantics encoding transcompiler edit notes ip the world s first cobol compilers interesting people org 12 june 1997 http www interesting people org archives interesting people 199706 msg00011 html t hart and m levin the new compiler aim 39 csail digital archive artificial intelligence laboratory series publications ai mit edu ftp publications ai mit edu ai publications pdf aim 039 pdf chakraborty p saxena p c katti c p pahwa g taneja s a new practicum in compiler construction computer applications in engineering education in press http onlinelibrary wiley com doi 10 1002 cae 20566 pdf the pl 0 compiler interpreter http www 246 dk pl0 html the acm digital library http www acm org classics dec95 t diagrams were first introduced for describing bootstrapping and cross compiling compilers in mckeeman et al a compiler generator 1971 conway described the broader concept before that with his uncol in 1958 to which bratman added in 1961 h bratman an alternate form of the uncol diagram comm acm 4 march 1961 3 p 142 later on others including p d terry gave an explanation and usage of t diagrams in their textbooks on the topic of compiler construction cf terry 1997 chapter 3 t diagrams are also now used to describe client server interconnectivity on the world wide web cf patrick closhen et al 1997 t diagrams as visual language to illustrate www technology darmstadt university of technology darmstadt germany etaps european joint conferences on theory and practice of software cf cc compiler construction subsection edit references compiler textbook references a collection of references to mainstream compiler construction textbooks aho alfred v sethi ravi and ullman jeffrey d compilers principles techniques and tools isbn 0 201 10088 6 link to publisher also known as the dragon book allen frances e a history of language processor technology in ibm ibm journal of research and development v 25 no 5 september 1981 allen randy and kennedy ken optimizing compilers for modern architectures morgan kaufmann publishers 2001 isbn 1 55860 286 0 appel andrew wilson modern compiler implementation in java 2nd edition cambridge university press 2002 isbn 0 521 82060 x modern compiler implementation in ml cambridge university press 1998 isbn 0 521 58274 1 bornat richard understanding and writing compilers a do it yourself guide macmillan publishing 1979 isbn 0 333 21732 2 cooper keith d and torczon linda engineering a compiler morgan kaufmann 2004 isbn 1 55860 699 8 leverett cattel hobbs newcomer reiner schatz wulf an overview of the production quality compiler compiler project in computer 13 8 38 49 august 1980 mckeeman william marshall horning james j wortman david b a compiler generator englewood cliffs n j 160 prentice hall 1970 isbn 0 13 155077 2 muchnick steven advanced compiler design and implementation morgan kaufmann publishers 1997 isbn 1 55860 320 4 scott michael lee programming language pragmatics morgan kaufmann 2005 2nd edition 912 pages isbn 0 12 633951 1 the author s site on this book srikant y n shankar priti the compiler design handbook optimizations and machine code generation crc press 2003 isbn 0 8493 1240 x terry patrick d compilers and compiler generators an introduction with c international thomson computer press 1997 isbn 1 85032 298 8 wirth niklaus compiler construction isbn 0 201 40353 6 addison wesley 1996 176 pages revised november 2005 edit external links wikibooks has a book on the topic of compiler construction the dictionary definition of compiler at wiktionary compilers at the open directory project compile howto basics of compiler design by torben gidius mogensen short animation explaining the key conceptual difference between compilers and interpreters 