it has been suggested that interpreted language be merged into this article or section discuss proposed since january 2013 this article has multiple issues please help improve it or discuss these issues on the talk page this article needs attention from an expert in computer science please add a reason or a talk parameter to this template to explain the issue with the article wikipedia wikiproject computer science wikiproject computer science may be able to help recruit an expert january 2013 the lead section of this article may need to be rewritten please discuss this issue on the talk page and read the layout guide to make sure the section will be inclusive of all essential details january 2013 this article needs additional citations for verification please help improve this article by adding citations to reliable sources unsourced material may be challenged and removed january 2013 this article may be too technical for most readers to understand please help improve this article to make it understandable to non experts without removing the technical details the talk page may contain suggestions january 2013 in computer science an interpreter is a computer program that executes i e performs instructions written in a programming language an interpreter generally uses one of the following strategies for program execution execute the source code directly translate source code into some efficient intermediate representation and immediately execute this explicitly execute stored precompiled code 1 made by a compiler which is part of the interpreter system early versions of the lisp programming language and dartmouth basic would be examples of the first type perl python matlab and ruby are examples of the second while ucsd pascal is an example of the third type source programs are compiled ahead of time and stored as machine independent code which is then linked at run time and executed by an interpreter and or compiler for jit systems some systems such as smalltalk contemporary versions of basic java and others may also combine two and three while interpretation and compilation are the two main means by which programming languages are implemented they are not mutually exclusive as most interpreting systems also perform some translation work just like compilers the terms interpreted language or compiled language signify that the canonical implementation of that language is an interpreter or a compiler respectively a high level language is ideally an abstraction independent of particular implementations contents 1 history 2 advantages and disadvantages of using interpreters 2 1 development cycle 2 2 distribution 2 3 efficiency 2 4 regress 3 variations 3 1 bytecode interpreters 3 2 abstract syntax tree interpreters 3 3 just in time compilation 4 applications 5 punched card interpreter 6 see also 7 notes and references 8 external links edit history the first interpreted high level language was probably lisp lisp was first implemented by steve russell on an ibm 704 computer russell had read john mccarthy s paper and realized to mccarthy s surprise that the lisp eval function could be implemented in machine code 2 the result was a working lisp interpreter which could be used to run lisp programs or more properly evaluate lisp expressions edit advantages and disadvantages of using interpreters programs are usually written in high level code which has to be converted into machine code for the cpu to execute it this conversion is done by either a compiler or an interpreter a compiler makes the conversion just once while an interpreter typically converts it every time a program is executed or in some languages like early versions of basic every time a single instruction is executed citation needed edit development cycle during the software development cycle programmers make frequent changes to source code citation needed when using a compiler each time a change is made to the source code they must wait for the compiler to translate the altered source files and link all of the binary code files together before the program can be executed the larger the program the longer the wait by contrast a programmer using an interpreter does a lot less waiting as the interpreter usually just needs to translate the code being worked on to an intermediate representation or not translate it at all thus requiring much less time before the changes can be tested citation needed edit distribution a compiler converts source code into binary instruction for a specific processor s architecture thus making it less portable this conversion is made just once on the developer s environment and after that the same binary can be distributed to the user s machines where it can be executed without further translation a cross compiler can generate binary code for the user machine even if it has a different processor than the machine where the code is compiled an interpreted program can be distributed as source code it needs to be translated in each final machine which takes more time but makes the program distribution independent of the machine s architecture however the portability of interpreted source code is dependent on the target machine actually having a suitable interpreter if the interpreter needs to be supplied along with the source the overall installation process is more complex than delivery of a monolithic executable citation needed the fact that interpreted code can easily be read and copied by humans can be of concern from the point of view of copyright however various systems of encryption and obfuscation exist delivery of intermediate code such as bytecode has a similar effect to obfuscation but bytecode could be decoded with a decompiler or disassembler citation needed edit efficiency the main disadvantage of interpreters is that when a program is interpreted it typically runs more slowly than if it had been compiled the difference in speeds could be tiny or great often an order of magnitude and sometimes more it generally takes longer to run a program under an interpreter than to run the compiled code but it can take less time to interpret it than the total time required to compile and run it this is especially important when prototyping and testing code when an edit interpret debug cycle can often be much shorter than an edit compile run debug cycle citation needed interpreting code is slower than running the compiled code because the interpreter must analyze each statement in the program each time it is executed and then perform the desired action whereas the compiled code just performs the action within a fixed context determined by the compilation this run time analysis is known as interpretive overhead access to variables is also slower in an interpreter because the mapping of identifiers to storage locations must be done repeatedly at run time rather than at compile time citation needed there are various compromises between the development speed when using an interpreter and the execution speed when using a compiler some systems such as some lisps allow interpreted and compiled code to call each other and to share variables this means that once a routine has been tested and debugged under the interpreter it can be compiled and thus benefit from faster execution while other routines are being developed citation needed many interpreters do not execute the source code as it stands but convert it into some more compact internal form many basic interpreters replace keywords with single byte tokens which can be used to find the instruction in a jump table a few interpreters such as the pbasic interpreter achieve even higher levels of program compaction by using a bit oriented rather than a byte oriented program memory structure where commands tokens occupy perhaps 5 bits nominally 16 bit constants are stored in a variable length code requiring 3 6 10 or 18 bits and address operands include a bit offset many basic interpreters can store and read back their own tokenized internal representation an interpreter might well use the same lexical analyzer and parser as the compiler and then interpret the resulting abstract syntax tree edit regress interpretation cannot be used as the sole method of execution even though an interpreter can itself be interpreted and so on a directly executed program is needed somewhere at the bottom of the stack citation needed edit variations edit bytecode interpreters main article bytecode there is a spectrum of possibilities between interpreting and compiling depending on the amount of analysis performed before the program is executed for example emacs lisp is compiled to bytecode which is a highly compressed and optimized representation of the lisp source but is not machine code and therefore not tied to any particular hardware this compiled code is then interpreted by a bytecode interpreter itself written in c the compiled code in this case is machine code for a virtual machine which is implemented not in hardware but in the bytecode interpreter the same approach is used with the forth code used in open firmware systems the source language is compiled into f code a bytecode which is then interpreted by a virtual machine citation needed control tables that do not necessarily ever need to pass through a compiling phase dictate appropriate algorithmic control flow via customized interpreters in similar fashion to bytecode interpreters edit abstract syntax tree interpreters in the spectrum between interpreting and compiling another approach is transforming the source code into an optimized abstract syntax tree ast then executing the program following this tree structure or using it to generate native code just in time 3 in this approach each sentence needs to be parsed just once as an advantage over bytecode the ast keeps the global program structure and relations between statements which is lost in a bytecode representation and when compressed provides a more compact representation 4 thus using ast has been proposed as a better intermediate format for just in time compilers than bytecode also it allows to perform better analysis during runtime however for interpreters an ast causes more overhead than a bytecode interpreter because of nodes related to syntax performing no useful work of a less sequential representation requiring traversal of more pointers and of overhead visiting the tree 5 edit just in time compilation further blurring the distinction between interpreters byte code interpreters and compilation is just in time compilation or jit a technique in which the intermediate representation is compiled to native machine code at runtime this confers the efficiency of running native code at the cost of startup time and increased memory use when the bytecode or ast is first compiled adaptive optimization is a complementary technique in which the interpreter profiles the running program and compiles its most frequently executed parts into native code both techniques are a few decades old appearing in languages such as smalltalk in the 1980s 6 just in time compilation has gained mainstream attention amongst language implementers in recent years with java the net framework and most modern javascript implementations now including jits citation needed edit applications interpreters are frequently used to execute command languages and glue languages since each operator executed in command language is usually an invocation of a complex routine such as an editor or compiler citation needed self modifying code can easily be implemented in an interpreted language this relates to the origins of interpretation in lisp and artificial intelligence research citation needed virtualisation machine code intended for one hardware architecture can be run on another using a virtual machine which is essentially an interpreter citation needed sandboxing an interpreter or virtual machine is not compelled to actually execute all the instructions the source code it is processing in particular it can refuse to execute code that violates any security constraints it is operating under citation needed edit punched card interpreter the term interpreter often referred to a piece of unit record equipment that could read punched cards and print the characters in human readable form on the card the ibm 550 numeric interpreter and ibm 557 alphabetic interpreter are typical examples from 1930 and 1954 respectively citation needed edit see also command line interpreter compiled language dynamic compilation interpreted language meta circular evaluator partial evaluation self interpreter edit notes and references in this sense the cpu is also an interpreter of machine instructions according to what reported by paul graham in hackers amp painters p 185 mccarthy said steve russell said look why don t i program this eval and i said to him ho ho you re confusing theory with practice this eval is intended for reading not for computing but he went ahead and did it that is he compiled the eval in my paper into ibm 704 machine code fixing bug and then advertised this as a lisp interpreter which it certainly was so at that point lisp had essentially the form that it has today ast intermediate representations lambda the ultimate forum a tree based alternative to java byte codes thomas kistler michael franz http webkit org blog 189 announcing squirrelfish l deutsch a schiffman efficient implementation of the smalltalk 80 system proceedings of 11th popl symposium 1984 edit external links ibm card interpreters page at columbia university theoretical foundations for practical totally functional programming chapter 7 especially doctoral dissertation tackling the problem of formalising what is an interpreter short animation explaining the key conceptual difference between interpreters and compilers this article is based on material taken from the free on line dictionary of computing prior to 1 november 2008 and incorporated under the relicensing terms of the gfdl version 1 3 or later 