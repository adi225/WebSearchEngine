software development process a software engineer programming at work activities and steps requirements specification architecture design implementation testing debugging deployment maintenance methodologies waterfall prototype model incremental iterative v model spiral scrum cleanroom rad dsdm rup xp agile lean dual vee model tdd fdd supporting disciplines configuration management documentation quality assurance sqa project management user experience design tools compiler debugger profiler gui designer ide build automation v t e software testing is an investigation conducted to provide stakeholders with information about the quality of the product or service under test 1 software testing can also provide an objective independent view of the software to allow the business to appreciate and understand the risks of software implementation test techniques include but are not limited to the process of executing a program or application with the intent of finding software bugs errors or other defects software testing can be stated as the process of validating and verifying that a computer program application product meets the requirements that guided its design and development works as expected can be implemented with the same characteristics and satisfies the needs of stakeholders software testing depending on the testing method employed can be implemented at any time in the development process traditionally most of the test effort occurs after the requirements have been defined and the coding process has been completed but in the agile approaches most of the test effort is on going as such the methodology of the test is governed by the chosen software development methodology different software development models will focus the test effort at different points in the development process newer development models such as agile often employ test driven development and place an increased portion of the testing in the hands of the developer before it reaches a formal team of testers in a more traditional model most of the test execution occurs after the requirements have been defined and the coding process has been completed contents 1 overview 1 1 defects and failures 2 input combinations and preconditions 3 economics 3 1 roles 4 history 5 testing methods 5 1 static vs dynamic testing 5 2 the box approach 5 2 1 white box testing 5 2 2 black box testing 5 2 3 grey box testing 5 3 visual testing 6 testing levels 6 1 unit testing 6 2 integration testing 6 3 system testing 6 4 acceptance testing 7 testing approach 7 1 top down and bottom up 8 objectives of testing 8 1 installation testing 8 2 compatibility testing 8 3 smoke and sanity testing 8 4 regression testing 8 5 acceptance testing 8 6 alpha testing 8 7 beta testing 8 8 functional vs non functional testing 8 9 destructive testing 8 10 software performance testing 8 11 usability testing 8 12 accessibility 8 13 security testing 8 14 internationalization and localization 8 15 development testing 9 the testing process 9 1 traditional cmmi or waterfall development model 9 2 agile or extreme development model 9 3 a sample testing cycle 10 automated testing 10 1 testing tools 10 2 measurement in software testing 11 testing artifacts 12 certifications 13 controversy 14 related processes 14 1 software verification and validation 14 2 software quality assurance sqa 15 see also 16 references 17 further reading 18 external links edit overview testing can never completely identify all the defects within software 2 instead it furnishes a criticism or comparison that compares the state and behavior of the product against oracles principles or mechanisms by which someone might recognize a problem these oracles may include but are not limited to specifications contracts 3 comparable products past versions of the same product inferences about intended or expected purpose user or customer expectations relevant standards applicable laws or other criteria a primary purpose of testing is to detect software failures so that defects may be discovered and corrected testing cannot establish that a product functions properly under all conditions but can only establish that it does not function properly under specific conditions 4 the scope of software testing often includes examination of code as well as execution of that code in various environments and conditions as well as examining the aspects of code does it do what it is supposed to do and do what it needs to do in the current culture of software development a testing organization may be separate from the development team there are various roles for testing team members information derived from software testing may be used to correct the process by which software is developed 5 every software product has a target audience for example the audience for video game software is completely different from banking software therefore when an organization develops or otherwise invests in a software product it can assess whether the software product will be acceptable to its end users its target audience its purchasers and other stakeholders software testing is the process of attempting to make this assessment edit defects and failures not all software defects are caused by coding errors one common source of expensive defects is caused by requirement gaps e g unrecognized requirements that result in errors of omission by the program designer 6 a common source of requirements gaps is non functional requirements such as testability scalability maintainability usability performance and security software faults occur through the following processes a programmer makes an error mistake which results in a defect fault bug in the software source code if this defect is executed in certain situations the system will produce wrong results causing a failure 7 not all defects will necessarily result in failures for example defects in dead code will never result in failures a defect can turn into a failure when the environment is changed examples of these changes in environment include the software being run on a new computer hardware platform alterations in source data or interacting with different software 7 a single defect may result in a wide range of failure symptoms edit input combinations and preconditions a very fundamental problem with software testing is that testing under all combinations of inputs and preconditions initial state is not feasible even with a simple product 4 8 this means that the number of defects in a software product can be very large and defects that occur infrequently are difficult to find in testing more significantly non functional dimensions of quality how it is supposed to be versus what it is supposed to do usability scalability performance compatibility reliability can be highly subjective something that constitutes sufficient value to one person may be intolerable to another software developers can t test everything but they can use combinatorial test design to identify the minimum number of tests needed to get the coverage they want combinatorial test design enables users to get greater test coverage with fewer tests whether they are looking for speed or test depth they can use combinatorial test design methods to build structured variation into their test cases 9 edit economics a study conducted by nist in 2002 reports that software bugs cost the u s economy 59 5 billion annually more than a third of this cost could be avoided if better software testing was performed 10 it is commonly believed that the earlier a defect is found the cheaper it is to fix it the following table shows the cost of fixing the defect depending on the stage it was found 11 for example if a problem in the requirements is found only post release then it would cost 10 100 times more to fix than if it had already been found by the requirements review with the advent of modern continuous deployment practices and cloud based services the cost of re deployment and maintenance may lessen over time cost to fix a defect time detected requirements architecture construction system test post release time introduced requirements 1 3 5 10 10 10 100 architecture 1 10 15 25 100 construction 1 10 10 25 edit roles software testing can be done by software testers until the 1980s the term software tester was used generally but later it was also seen as a separate profession regarding the periods and the different goals in software testing 12 different roles have been established manager test lead test designer tester automation developer and test administrator edit history the separation of debugging from testing was initially introduced by glenford j myers in 1979 13 although his attention was on breakage testing a successful test is one that finds a bug 13 14 it illustrated the desire of the software engineering community to separate fundamental development activities such as debugging from that of verification dave gelperin and william c hetzel classified in 1988 the phases and goals in software testing in the following stages 15 until 1956 debugging oriented 16 1957 1978 demonstration oriented 17 1979 1982 destruction oriented 18 1983 1987 evaluation oriented 19 1988 2000 prevention oriented 20 edit testing methods edit static vs dynamic testing there are many approaches to software testing reviews walkthroughs or inspections are referred to as static testing whereas actually executing programmed code with a given set of test cases is referred to as dynamic testing static testing can be omitted and unfortunately in practice often is dynamic testing takes place when the program itself is used dynamic testing may begin before the program is 100 complete in order to test particular sections of code and are applied to discrete functions or modules typical techniques for this are either using stubs drivers or execution from a debugger environment edit the box approach software testing methods are traditionally divided into white and black box testing these two approaches are used to describe the point of view that a test engineer takes when designing test cases edit white box testing main article white box testing white box testing also known as clear box testing glass box testing transparent box testing and structural testing tests internal structures or workings of a program as opposed to the functionality exposed to the end user in white box testing an internal perspective of the system as well as programming skills are used to design test cases the tester chooses inputs to exercise paths through the code and determine the appropriate outputs this is analogous to testing nodes in a circuit e g in circuit testing ict while white box testing can be applied at the unit integration and system levels of the software testing process it is usually done at the unit level it can test paths within a unit paths between units during integration and between subsystems during a system level test though this method of test design can uncover many errors or problems it might not detect unimplemented parts of the specification or missing requirements techniques used in white box testing include api testing application programming interface testing of the application using public and private apis code coverage creating tests to satisfy some criteria of code coverage e g the test designer can create tests to cause all statements in the program to be executed at least once fault injection methods intentionally introducing faults to gauge the efficacy of testing strategies mutation testing methods static testing methods code coverage tools can evaluate the completeness of a test suite that was created with any method including black box testing this allows the software team to examine parts of a system that are rarely tested and ensures that the most important function points have been tested 21 code coverage as a software metric can be reported as a percentage for function coverage which reports on functions executed statement coverage which reports on the number of lines executed to complete the test 100 statement coverage ensures that all code paths or branches in terms of control flow are executed at least once this is helpful in ensuring correct functionality but not sufficient since the same code may process different inputs correctly or incorrectly edit black box testing main article black box testing black box diagram black box testing treats the software as a black box examining functionality without any knowledge of internal implementation the tester is only aware of what the software is supposed to do not how it does it 22 black box testing methods include equivalence partitioning boundary value analysis all pairs testing state transition tables decision table testing fuzz testing model based testing use case testing exploratory testing and specification based testing specification based testing aims to test the functionality of software according to the applicable requirements 23 this level of testing usually requires thorough test cases to be provided to the tester who then can simply verify that for a given input the output value or behavior either is or is not the same as the expected value specified in the test case test cases are built around specifications and requirements i e what the application is supposed to do it uses external descriptions of the software including specifications requirements and designs to derive test cases these tests can be functional or non functional though usually functional specification based testing may be necessary to assure correct functionality but it is insufficient to guard against complex or high risk situations 24 one advantage of the black box technique is that no programming knowledge is required whatever biases the programmers may have had the tester likely has a different set and may emphasize different areas of functionality on the other hand black box testing has been said to be like a walk in a dark labyrinth without a flashlight 25 because they do not examine the source code there are situations when a tester writes many test cases to check something that could have been tested by only one test case or leaves some parts of the program untested this method of test can be applied to all levels of software testing unit integration system and acceptance it typically comprises most if not all testing at higher levels but can also dominate unit testing as well edit grey box testing main article gray box testing grey box testing american spelling gray box testing involves having knowledge of internal data structures and algorithms for purposes of designing tests while executing those tests at the user or black box level the tester is not required to have full access to the software s source code 26 not in citation given manipulating input data and formatting output do not qualify as grey box because the input and output are clearly outside of the black box that we are calling the system under test this distinction is particularly important when conducting integration testing between two modules of code written by two different developers where only the interfaces are exposed for test however modifying a data repository does qualify as grey box as the user would not normally be able to change the data outside of the system under test grey box testing may also include reverse engineering to determine for instance boundary values or error messages by knowing the underlying concepts of how the software works the tester makes better informed testing choices while testing the software from outside typically a grey box tester will be permitted to set up an isolated testing environment with activities such as seeding a database the tester can observe the state of the product being tested after performing certain actions such as executing sql statements against the database and then executing queries to ensure that the expected changes have been reflected grey box testing implements intelligent test scenarios based on limited information this will particularly apply to data type handling exception handling and so on 27 edit visual testing the aim of visual testing is to provide developers with the ability to examine what was happening at the point of software failure by presenting the data in such a way that the developer can easily nd the information he requires and the information is expressed clearly 28 29 at the core of visual testing is the idea that showing someone a problem or a test failure rather than just describing it greatly increases clarity and understanding visual testing therefore requires the recording of the entire test process capturing everything that occurs on the test system in video format output videos are supplemented by real time tester input via picture in a picture webcam and audio commentary from microphones visual testing provides a number of advantages the quality of communication is increased dramatically because testers can show the problem and the events leading up to it to the developer as opposed to just describing it and the need to replicate test failures will cease to exist in many cases the developer will have all the evidence he requires of a test failure and can instead focus on the cause of the fault and how it should be fixed visual testing is particularly well suited for environments that deploy agile methods in their development of software since agile methods require greater communication between testers and developers and collaboration within small teams citation needed ad hoc testing and exploratory testing are important methodologies for checking software integrity because they require less preparation time to implement while the important bugs can be found quickly in ad hoc testing where testing takes place in an improvised impromptu way the ability of a test tool to visually record everything that occurs on a system becomes very important clarification needed citation needed visual testing is gathering recognition in customer acceptance and usability testing because the test can be used by many individuals involved in the development process citation needed for the customer it becomes easy to provide detailed bug reports and feedback and for program users visual testing can record user actions on screen as well as their voice and image to provide a complete picture at the time of software failure for the developer further information graphical user interface testing edit testing levels tests are frequently grouped by where they are added in the software development process or by the level of specificity of the test the main levels during the development process as defined by the swebok guide are unit integration and system testing that are distinguished by the test target without implying a specific process model 30 other test levels are classified by the testing objective 30 edit unit testing main article unit testing unit testing also known as component testing refers to tests that verify the functionality of a specific section of code usually at the function level in an object oriented environment this is usually at the class level and the minimal unit tests include the constructors and destructors 31 these types of tests are usually written by developers as they work on code white box style to ensure that the specific function is working as expected one function might have multiple tests to catch corner cases or other branches in the code unit testing alone cannot verify the functionality of a piece of software but rather is used to assure that the building blocks the software uses work independently of each other edit integration testing main article integration testing integration testing is any type of software testing that seeks to verify the interfaces between components against a software design software components may be integrated in an iterative way or all together big bang normally the former is considered a better practice since it allows interface issues to be localised more quickly and fixed integration testing works to expose defects in the interfaces and interaction between integrated components modules progressively larger groups of tested software components corresponding to elements of the architectural design are integrated and tested until the software works as a system 32 edit system testing main article system testing system testing tests a completely integrated system to verify that it meets its requirements 33 edit acceptance testing main article acceptance testing at last the system is delivered to the user for acceptance testing edit testing approach edit top down and bottom up bottom up testing is an approach to integrated testing where the lowest level components modules procedures and functions are tested first then integrated and used to facilitate the testing of higher level components after the integration testing of lower level integrated modules the next level of modules will be formed and can be used for integration testing the process is repeated until the components at the top of the hierarchy are tested this approach is helpful only when all or most of the modules of the same development level are ready citation needed this method also helps to determine the levels of software developed and makes it easier to report testing progress in the form of a percentage citation needed top down testing is an approach to integrated testing where the top integrated modules are tested and the branch of the module is tested step by step until the end of the related module in both method stubs and drivers are used to stand in for missing components and are replaced as the levels are completed edit objectives of testing edit installation testing main article installation testing an installation test assures that the system is installed correctly and working at actual customer s hardware edit compatibility testing main article compatibility testing a common cause of software failure real or perceived is a lack of its compatibility with other application software operating systems or operating system versions old or new or target environments that differ greatly from the original such as a terminal or gui application intended to be run on the desktop now being required to become a web application which must render in a web browser for example in the case of a lack of backward compatibility this can occur because the programmers develop and test software only on the latest version of the target environment which not all users may be running this results in the unintended consequence that the latest work may not function on earlier versions of the target environment or on older hardware that earlier versions of the target environment was capable of using sometimes such issues can be fixed by proactively abstracting operating system functionality into a separate program module or library edit smoke and sanity testing sanity testing determines whether it is reasonable to proceed with further testing smoke testing is used to determine whether there are serious problems with a piece of software for example as a build verification test edit regression testing main article regression testing regression testing focuses on finding defects after a major code change has occurred specifically it seeks to uncover software regressions or old bugs that have come back such regressions occur whenever software functionality that was previously working correctly stops working as intended typically regressions occur as an unintended consequence of program changes when the newly developed part of the software collides with the previously existing code common methods of regression testing include re running previously run tests and checking whether previously fixed faults have re emerged the depth of testing depends on the phase in the release process and the risk of the added features they can either be complete for changes added late in the release or deemed to be risky to very shallow consisting of positive tests on each feature if the changes are early in the release or deemed to be of low risk edit acceptance testing main article acceptance testing acceptance testing can mean one of two things a smoke test is used as an acceptance test prior to introducing a new build to the main testing process i e before integration or regression acceptance testing performed by the customer often in their lab environment on their own hardware is known as user acceptance testing uat acceptance testing may be performed as part of the hand off process between any two phases of development citation needed edit alpha testing alpha testing is simulated or actual operational testing by potential users customers or an independent test team at the developers site alpha testing is often employed for off the shelf software as a form of internal acceptance testing before the software goes to beta testing 34 edit beta testing beta testing comes after alpha testing and can be considered a form of external user acceptance testing versions of the software known as beta versions are released to a limited audience outside of the programming team the software is released to groups of people so that further testing can ensure the product has few faults or bugs sometimes beta versions are made available to the open public to increase the feedback field to a maximal number of future users citation needed edit functional vs non functional testing functional testing refers to activities that verify a specific action or function of the code these are usually found in the code requirements documentation although some development methodologies work from use cases or user stories functional tests tend to answer the question of can the user do this or does this particular feature work non functional testing refers to aspects of the software that may not be related to a specific function or user action such as scalability or other performance behavior under certain constraints or security testing will determine the flake point the point at which extremes of scalability or performance leads to unstable execution non functional requirements tend to be those that reflect the quality of the product particularly in the context of the suitability perspective of its users edit destructive testing main article destructive testing destructive testing attempts to cause the software or a sub system to fail it verifies that the software functions properly even when it receives invalid or unexpected inputs thereby establishing the robustness of input validation and error management routines citation needed software fault injection in the form of fuzzing is an example of failure testing various commercial non functional testing tools are linked from the software fault injection page there are also numerous open source and free software tools available that perform destructive testing further information exception handling 160 and 160 recovery testing edit software performance testing performance testing is generally executed to determine how a system or sub system performs in terms of responsiveness and stability under a particular workload it can also serve to investigate measure validate or verify other quality attributes of the system such as scalability reliability and resource usage load testing is primarily concerned with testing that the system can continue to operate under a specific load whether that be large quantities of data or a large number of users this is generally referred to as software scalability the related load testing activity of when performed as a non functional activity is often referred to as endurance testing volume testing is a way to test software functions even when certain components for example a file or database increase radically in size stress testing is a way to test reliability under unexpected or rare workloads stability testing often referred to as load or endurance testing checks to see if the software can continuously function well in or above an acceptable period there is little agreement on what the specific goals of performance testing are the terms load testing performance testing reliability testing and volume testing are often used interchangeably further information scalability testing edit usability testing usability testing is needed to check if the user interface is easy to use and understand it is concerned mainly with the use of the application edit accessibility accessibility testing may include compliance with standards such as americans with disabilities act of 1990 section 508 amendment to the rehabilitation act of 1973 web accessibility initiative wai of the world wide web consortium w3c edit security testing security testing is essential for software that processes confidential data to prevent system intrusion by hackers edit internationalization and localization the general ability of software to be internationalized and localized can be automatically tested without actual translation by using pseudolocalization it will verify that the application still works even after it has been translated into a new language or adapted for a new culture such as different currencies or time zones 35 actual translation to human languages must be tested too possible localization failures include software is often localized by translating a list of strings out of context and the translator may choose the wrong translation for an ambiguous source string technical terminology may become inconsistent if the project is translated by several people without proper coordination or if the translator is imprudent literal word for word translations may sound inappropriate artificial or too technical in the target language untranslated messages in the original language may be left hard coded in the source code some messages may be created automatically at run time and the resulting string may be ungrammatical functionally incorrect misleading or confusing software may use a keyboard shortcut which has no function on the source language s keyboard layout but is used for typing characters in the layout of the target language software may lack support for the character encoding of the target language fonts and font sizes which are appropriate in the source language may be inappropriate in the target language for example cjk characters may become unreadable if the font is too small a string in the target language may be longer than the software can handle this may make the string partly invisible to the user or cause the software to crash or malfunction software may lack proper support for reading or writing bi directional text software may display images with text that was not localized localized operating systems may have differently named system configuration files and environment variables and different formats for date and currency edit development testing main article development testing development testing is a software development process that involves synchronized application of a broad spectrum of defect prevention and detection strategies in order to reduce software development risks time and costs it is performed by the software developer or engineer during the construction phase of the software development lifecycle rather than replace traditional qa focuses it augments it development testing aims to eliminate construction errors before code is promoted to qa this strategy is intended to increase the quality of the resulting software as well as the efficiency of the overall development and qa process depending on the organization s expectations for software development development testing might include static code analysis data flow analysis metrics analysis peer code reviews unit testing code coverage analysis traceability and other software verification practices edit the testing process edit traditional cmmi or waterfall development model a common practice of software testing is that testing is performed by an independent group of testers after the functionality is developed before it is shipped to the customer 36 this practice often results in the testing phase being used as a project buffer to compensate for project delays thereby compromising the time devoted to testing 37 another practice is to start software testing at the same moment the project starts and it is a continuous process until the project finishes 38 further information capability maturity model integration and waterfall model edit agile or extreme development model in contrast some emerging software disciplines such as extreme programming and the agile software development movement adhere to a test driven software development model in this process unit tests are written first by the software engineers often with pair programming in the extreme programming methodology of course these tests fail initially as they are expected to then as code is written it passes incrementally larger portions of the test suites the test suites are continuously updated as new failure conditions and corner cases are discovered and they are integrated with any regression tests that are developed unit tests are maintained along with the rest of the software source code and generally integrated into the build process with inherently interactive tests being relegated to a partially manual build acceptance process the ultimate goal of this test process is to achieve continuous integration where software updates can be published to the public frequently 39 40 edit a sample testing cycle although variations exist between organizations there is a typical cycle for testing 41 the sample below is common among organizations employing the waterfall development model requirements analysis testing should begin in the requirements phase of the software development life cycle during the design phase testers work with developers in determining what aspects of a design are testable and with what parameters those tests work test planning test strategy test plan testbed creation since many activities will be carried out during testing a plan is needed test development test procedures test scenarios test cases test datasets test scripts to use in testing software test execution testers execute the software based on the plans and test documents then report any errors found to the development team test reporting once testing is completed testers generate metrics and make final reports on their test effort and whether or not the software tested is ready for release test result analysis or defect analysis is done by the development team usually along with the client in order to decide what defects should be assigned fixed rejected i e found software working properly or deferred to be dealt with later defect retesting once a defect has been dealt with by the development team it is retested by the testing team aka resolution testing regression testing it is common to have a small test program built of a subset of tests for each integration of new modified or fixed software in order to ensure that the latest delivery has not ruined anything and that the software product as a whole is still working correctly test closure once the test meets the exit criteria the activities such as capturing the key outputs lessons learned results logs documents related to the project are archived and used as a reference for future projects edit automated testing main article test automation many programming groups are relying more and more on automated testing especially groups that use test driven development there are many frameworks to write tests in and continuous integration software will run tests automatically every time code is checked into a version control system while automation cannot reproduce everything that a human can do and all the ways they think of doing it it can be very useful for regression testing however it does require a well developed test suite of testing scripts in order to be truly useful edit testing tools program testing and fault detection can be aided significantly by testing tools and debuggers testing debug tools include features such as program monitors permitting full or partial monitoring of program code including instruction set simulator permitting complete instruction level monitoring and trace facilities program animation permitting step by step execution and conditional breakpoint at source level or in machine code code coverage reports formatted dump or symbolic debugging tools allowing inspection of program variables on error or at chosen points automated functional gui testing tools are used to repeat system level tests through the gui benchmarks allowing run time performance comparisons to be made performance analysis or profiling tools that can help to highlight hot spots and resource usage some of these features may be incorporated into an integrated development environment ide a regression testing technique is to have a standard set of tests which cover existing functionality that result in persistent tabular data and to compare pre change data to post change data where there should not be differences using a tool like diffkit differences detected indicate unexpected functionality changes or regression edit measurement in software testing main article software quality usually quality is constrained to such topics as correctness completeness security citation needed but can also include more technical requirements as described under the iso standard iso iec 9126 such as capability reliability efficiency portability maintainability compatibility and usability there are a number of frequently used software metrics or measures which are used to assist in determining the state of the software or the adequacy of the testing edit testing artifacts the software testing process can produce several artifacts test plan a test specification is called a test plan the developers are well aware what test plans will be executed and this information is made available to management and the developers the idea is to make them more cautious when developing their code or making additional changes some companies have a higher level document called a test strategy traceability matrix a traceability matrix is a table that correlates requirements or design documents to test documents it is used to change tests when related source documents are changed to select test cases for execution when planning for regression tests by considering requirement coverage test case a test case normally consists of a unique identifier requirement references from a design specification preconditions events a series of steps also known as actions to follow input output expected result and actual result clinically defined a test case is an input and an expected result 42 this can be as pragmatic as for condition x your derived result is y whereas other test cases described in more detail the input scenario and what results might be expected it can occasionally be a series of steps but often steps are contained in a separate test procedure that can be exercised against multiple test cases as a matter of economy but with one expected result or expected outcome the optional fields are a test case id test step or order of execution number related requirement s depth test category author and check boxes for whether the test is automatable and has been automated larger test cases may also contain prerequisite states or steps and descriptions a test case should also contain a place for the actual result these steps can be stored in a word processor document spreadsheet database or other common repository in a database system you may also be able to see past test results who generated the results and what system configuration was used to generate those results these past results would usually be stored in a separate table test script a test script is a procedure or programing code that replicates user actions initially the term was derived from the product of work created by automated regression test tools test case will be a baseline to create test scripts using a tool or a program test suite the most common term for a collection of test cases is a test suite the test suite often also contains more detailed instructions or goals for each collection of test cases it definitely contains a section where the tester identifies the system configuration used during testing a group of test cases may also contain prerequisite states or steps and descriptions of the following tests test fixture or test data in most cases multiple sets of values or data are used to test the same functionality of a particular feature all the test values and changeable environmental components are collected in separate files and stored as test data it is also useful to provide this data to the client and with the product or a project test harness the software tools samples of data input and output and configurations are all referred to collectively as a test harness edit certifications several certification programs exist to support the professional aspirations of software testers and quality assurance specialists no certification now offered actually requires the applicant to show their ability to test software no certification is based on a widely accepted body of knowledge this has led some to declare that the testing field is not ready for certification 43 certification itself cannot measure an individual s productivity their skill or practical knowledge and cannot guarantee their competence or professionalism as a tester 44 software testing certification types exam based formalized exams which need to be passed can also be learned by self study e g for istqb or qai 45 education based instructor led sessions where each course has to be passed e g international institute for software testing iist testing certifications certified associate in software testing cast offered by the qai 46 cate offered by the international institute for software testing 47 certified manager in software testing cmst offered by the qai 46 certified test manager ctm offered by international institute for software testing 47 certified software tester cste offered by the quality assurance institute qai 46 certified software test professional cstp offered by the international institute for software testing 47 cstp tm australian version offered by k j ross amp associates 48 iseb offered by the information systems examinations board istqb certified tester foundation level ctfl offered by the international software testing qualification board 49 50 istqb certified tester advanced level ctal offered by the international software testing qualification board 49 50 tmpf tmap next foundation offered by the examination institute for information science 51 tmpa tmap next advanced offered by the examination institute for information science 51 quality assurance certifications cmsq offered by the quality assurance institute qai 46 csqa offered by the quality assurance institute qai 46 csqe offered by the american society for quality asq 52 cqia offered by the american society for quality asq 52 edit controversy some of the major software testing controversies include what constitutes responsible software testing 160 members of the context driven school of testing 53 believe that there are no best practices of testing but rather that testing is a set of skills that allow the tester to select or invent testing practices to suit each unique situation 54 agile vs traditional 160 should testers learn to work under conditions of uncertainty and constant change or should they aim at process maturity the agile testing movement has received growing popularity since 2006 mainly in commercial circles 55 56 whereas government and military 57 software providers use this methodology but also the traditional test last models e g in the waterfall model citation needed exploratory test vs scripted 58 should tests be designed at the same time as they are executed or should they be designed beforehand manual testing vs automated 160 some writers believe that test automation is so expensive relative to its value that it should be used sparingly 59 more in particular test driven development states that developers should write unit tests of the xunit type before coding the functionality the tests then can be considered as a way to capture and implement the requirements software design vs software implementation 60 should testing be carried out only at the end or throughout the whole process who watches the watchmen 160 the idea is that any form of observation is also an interaction the act of testing can also affect that which is being tested 61 edit related processes edit software verification and validation main article verification and validation software software testing is used in association with verification and validation 62 verification have we built the software right i e does it implement the requirements validation have we built the right software i e do the requirements satisfy the customer the terms verification and validation are commonly used interchangeably in the industry it is also common to see these two terms incorrectly defined according to the ieee standard glossary of software engineering terminology verification is the process of evaluating a system or component to determine whether the products of a given development phase satisfy the conditions imposed at the start of that phase validation is the process of evaluating a system or component during or at the end of the development process to determine whether it satisfies specified requirements according to the is0 9000 standard verification is confirmation by examination and through provision of objective evidence that specified requirements have been fulfilled validation is confirmation by examination and through provision of objective evidence that the requirements for a specific intended use or application have been fulfilled edit software quality assurance sqa software testing is a part of the software quality assurance sqa process 4 in sqa software process specialists and auditors are concerned for the software development process rather than just the artifacts such as documentation code and systems they examine and change the software engineering process itself to reduce the number of faults that end up in the delivered software the so called defect rate what constitutes an acceptable defect rate depends on the nature of the software a flight simulator video game would have much higher defect tolerance than software for an actual airplane although there are close links with sqa testing departments often exist independently and there may be no sqa function in some companies citation needed software testing is a task intended to detect defects in software by contrasting a computer program s expected results with its actual results for a given set of inputs by contrast qa quality assurance is the implementation of policies and procedures intended to prevent defects from occurring in the first place edit see also software testing portal book software testing dynamic program analysis formal verification independent test organization manual testing orthogonal array testing pair testing reverse semantic traceability software testability orthogonal defect classification test management tools web testing edit references exploratory testing cem kaner florida institute of technology quality assurance institute worldwide annual software testing conference orlando fl november 2006 software testing by jiantao pan carnegie mellon university leitner a ciupa i oriol m meyer b fiva a contract driven development test driven development writing test cases proceedings of esec fse 07 european software engineering conference and the acm sigsoft symposium on the foundations of software engineering 2007 dubrovnik croatia september 2007 a b c kaner cem falk jack and nguyen hung quoc 1999 testing computer software 2nd ed new york et al john wiley and sons inc pp 160 480 pages isbn 160 0 471 35846 0 kolawa adam huizinga dorota 2007 automated defect prevention best practices in software management wiley ieee computer society press pp 160 41 43 isbn 160 0 470 04212 5 http www wiley com wileycda wileytitle productcd 0470042125 html kolawa adam huizinga dorota 2007 automated defect prevention best practices in software management wiley ieee computer society press p 160 426 isbn 160 0 470 04212 5 http www wiley com wileycda wileytitle productcd 0470042125 html a b section 1 1 2 certified tester foundation level syllabus international software testing qualifications board principle 2 section 1 3 certified tester foundation level syllabus international software testing qualifications board proceedings from the 5th international conference on software testing and validation icst software competence center hagenberg test design lessons learned and practical implications http ieeexplore ieee org xpl freeabs all jsp arnumber 4578383 software errors cost u s economy 59 5 billion annually nist report mcconnell steve 2004 code complete 2nd ed microsoft press p 160 29 isbn 160 0 7356 1967 0 see d gelperin and w c hetzel a b myers glenford j 1979 the art of software testing john wiley and sons isbn 160 0 471 04328 1 company people s computer 1987 dr dobb s journal of software tools for the professional programmer dr dobb s journal of software tools for the professional programmer m amp t pub 12 1 6 116 http books google com id 7roiaaaaiaaj gelperin d b hetzel 1988 the growth of software testing cacm 31 6 issn 160 0001 0782 until 1956 it was the debugging oriented period when testing was often associated to debugging there was no clear difference between testing and debugging gelperin d b hetzel 1988 the growth of software testing cacm 31 6 issn 160 0001 0782 from 1957 1978 there was the demonstration oriented period where debugging and testing was distinguished now in this period it was shown that software satisfies the requirements gelperin d b hetzel 1988 the growth of software testing cacm 31 6 issn 160 0001 0782 the time between 1979 1982 is announced as the destruction oriented period where the goal was to find errors gelperin d b hetzel 1988 the growth of software testing cacm 31 6 issn 160 0001 0782 1983 1987 is classified as the evaluation oriented period intention here is that during the software lifecycle a product evaluation is provided and measuring quality gelperin d b hetzel 1988 the growth of software testing cacm 31 6 issn 160 0001 0782 from 1988 on it was seen as prevention oriented period where tests were to demonstrate that software satisfies its specification to detect faults and to prevent faults gelperin d b hetzel 1988 the growth of software testing cacm 31 6 issn 160 0001 0782 introduction code coverage analysis steve cornett ron patton software testing laycock g t 1993 postscript the theory and practice of specification based software testing dept of computer science sheffield university uk http www mcs le ac uk people gtl1 thesis ps gz retrieved 2008 02 13 bach james june 1999 risk and requirements based testing pdf computer 32 6 113 114 http www satisfice com articles requirements based testing pdf retrieved 2008 08 19 savenkov roman 2008 how to become a software tester roman savenkov consulting p 160 159 isbn 160 978 0 615 23372 7 patton ron software testing soa testing tools for black white and gray box soa testing techniques crosschecknet com http www crosschecknet com soa testing black white gray box php retrieved 2012 12 10 visual testing of software helsinki university of technology pdf http www cs hut fi jlonnber visualtesting pdf retrieved 2012 01 13 article on visual testing in test magazine testmagazine co uk http www testmagazine co uk 2011 04 visual testing retrieved 2012 01 13 a b swebok guide chapter 5 computer org http www computer org portal web swebok html ch5 ref2 1 retrieved 2012 01 13 binder robert v 1999 testing object oriented systems objects patterns and tools addison wesley professional p 160 45 isbn 160 0 201 80938 9 beizer boris 1990 software testing techniques second ed new york van nostrand reinhold pp 160 21 430 isbn 160 0 442 20672 0 ieee 1990 ieee standard computer dictionary a compilation of ieee standard computer glossaries new york ieee isbn 160 1 55937 079 3 van veenendaal erik standard glossary of terms used in software testing http www astqb org get certified istqb syllabi the istqb software tester certification body of knowledge retrieved 4 january 2013 globalization step by step the world ready approach to testing microsoft developer network msdn microsoft com http msdn microsoft com en us goglobal bb688148 retrieved 2012 01 13 etestinghub online free software testing tutorial e testing phase in software testing etestinghub com http www etestinghub com testing lifecycles php 2 retrieved 2012 01 13 myers glenford j 1979 the art of software testing john wiley and sons pp 160 145 146 isbn 160 0 471 04328 1 dustin elfriede 2002 effective software testing addison wesley p 160 3 isbn 160 0 201 79429 2 marchenko artem november 16 2007 xp practice continuous integration http agilesoftwaredevelopment com xp practices continuous integration retrieved 2009 11 16 gurses levent february 19 2007 agile 101 what is continuous integration http www jacoozi com blog p 18 retrieved 2009 11 16 pan jiantao spring 1999 software testing 18 849b dependable embedded systems topics in dependable embedded systems electrical and computer engineering department carnegie mellon university http www ece cmu edu koopman des s99 sw testing ieee 1998 ieee standard for software test documentation new york ieee isbn 160 0 7381 1443 x kaner cem 2001 nsf grant proposal to lay a foundation for significant improvements in the quality of academic and commercial courses in software testing pdf http www testingeducation org general nsf grant pdf kaner cem 2003 measuring the effectiveness of software testers pdf http www testingeducation org a mest pdf black rex december 2008 advanced software testing vol 2 guide to the istqb advanced certification as an advanced test manager santa barbara rocky nook publisher isbn 160 1 933952 36 9 a b c d e quality assurance institute qaiglobalinstitute com http www qaiglobalinstitute com retrieved 2012 01 13 a b c international institute for software testing testinginstitute com http www testinginstitute com retrieved 2012 01 13 k j ross amp associates dead link a b istqb http www istqb org a b istqb in the u s http www astqb org a b exin examination institute for information science exin exams com http www exin exams com retrieved 2012 01 13 a b american society for quality asq org http www asq org retrieved 2012 01 13 context driven testing com context driven testing com http www context driven testing com retrieved 2012 01 13 article on taking agile traits without the agile method technicat com http www technicat com writing process html retrieved 2012 01 13 we re all part of the story by david strom july 1 2009 ieee article about differences in adoption of agile trends between experienced managers vs young students of the project management institute see also agile adoption study from 2007 willison john s april 2004 agile software development for an agile force crosstalk stsc april 2004 archived from the original on unknown http web archive org web 20051029135922 http www stsc hill af mil crosstalk 2004 04 0404willison html ieee article on exploratory vs non exploratory testing ieeexplore ieee org http ieeexplore ieee org iel5 10351 32923 01541817 pdf arnumber 1541817 retrieved 2012 01 13 an example is mark fewster dorothy graham software test automation addison wesley 1999 isbn 0 201 33140 3 article referring to other links questioning the necessity of unit testing java dzone com http java dzone com news why evangelising unit testing retrieved 2012 01 13 microsoft development network discussion on exactly this topic dead link tran eushiuan 1999 verification validation certification in koopman p topics in dependable embedded systems usa carnegie mellon university http www ece cmu edu koopman des s99 verification index html retrieved 2008 01 13 edit further reading bertrand meyer seven principles of software testing computer vol 41 no 8 pp 160 99 101 aug 2008 doi 10 1109 mc 2008 306 available online edit external links at wikiversity you can learn more and teach others about software testing at the department of software testing software testing tools and products at the open directory project software that makes software better economist com v t e major fields of computer science mathematical foundations mathematical logic set theory number theory graph theory type theory category theory numerical analysis information theory combinatorics boolean algebra theory of computation automata theory computability theory computational complexity theory quantum computing theory algorithms data structures analysis of algorithms algorithm design computational geometry programming languages compilers parsers interpreters procedural programming object oriented programming functional programming logic programming programming paradigms concurrent parallel distributed systems multiprocessing grid computing concurrency control software engineering requirements analysis software design computer programming formal methods software testing software development process system architecture computer architecture computer organization operating systems telecommunication networking computer audio routing network topology cryptography databases database management systems relational databases sql transactions database indexes data mining artificial intelligence automated reasoning computational linguistics computer vision evolutionary computation expert systems machine learning natural language processing robotics computer graphics visualization computer animation image processing human computer interaction computer accessibility user interfaces wearable computing ubiquitous computing virtual reality scientific computing artificial life bioinformatics cognitive science computational chemistry computational neuroscience computational physics numerical algorithms symbolic mathematics note computer science can also be divided into different topics or fields according to the acm computing classification system v t e software engineering fields computer programming formal methods requirements analysis software deployment software design software maintenance software testing systems analysis concepts data modeling enterprise architecture functional specification modeling language orthogonality programming paradigm software software architecture software development methodology software development process software quality software quality assurance software archaeology structured analysis orientations agile aspect oriented object orientation ontology service orientation sdlc models developmental agile eup executable uml incremental model iterative model rup scrum prototype model spiral model v model waterfall model xp other spice cmmi data model er model function model information model metamodeling object model systems model view model languages idef uml sysml software engineers kent beck grady booch fred brooks barry boehm peter chen ward cunningham ole johan dahl tom demarco martin fowler c a r hoare watts humphrey michael a jackson ivar jacobson james martin stephen j mellor bertrand meyer david parnas winston w royce james rumbaugh niklaus wirth edward yourdon victor basili related fields computer science computer engineering enterprise engineering history management project management quality management software ergonomics systems engineering category commons 