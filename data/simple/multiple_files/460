this article needs additional citations for verification please help improve this article by adding citations to reliable sources unsourced material may be challenged and removed february 2011 this article needs attention from an expert in computer science please add a reason or a talk parameter to this template to explain the issue with the article wikiproject computer science or the computer science portal may be able to help recruit an expert january 2009 programming paradigms action agent oriented aspect oriented automata based component based flow based pipelined concatenative concurrent computing relativistic programming data driven declarative contrast imperative constraint dataflow cell oriented spreadsheets reactive intensional functional logic abductive logic answer set constraint logic functional logic inductive logic end user programming event driven service oriented time driven expression oriented feature oriented function level contrast value level generic imperative contrast declarative procedural language oriented discipline specific domain specific grammar oriented dialecting intentional metaprogramming automatic reflective attribute oriented homoiconic template policy based non structured contrast structured array nondeterministic parallel computing process oriented programming in the large and small semantic structured contrast non structured modular contrast monolithic object oriented by separation of concerns aspect oriented role oriented subject oriented class based prototype based recursive value level contrast function level v t e a programming paradigm is a fundamental style of computer programming there are four main paradigms object oriented imperative functional and logic programming 1 their foundations are distinct models of computation turing machine for object oriented and imperative programming lambda calculus for functional programming and first order logic for logic programming contents 1 overview 2 multi paradigm programming language 3 history 4 see also 5 references 6 external links edit overview a programming model is an abstraction of a computer system for example the von neumann model is a model used in traditional sequential computers for parallel computing there are many possible models typically reflecting different ways processors can be interconnected the most common are based on shared memory distributed memory with message passing or a hybrid of the two a programming language can support multiple paradigms for example programs written in c or object pascal can be purely procedural or purely object oriented or contain elements of both paradigms software designers and programmers decide how to use those paradigm elements in object oriented programming programmers can think of a program as a collection of interacting objects while in functional programming a program can be thought of as a sequence of stateless function evaluations when programming computers or systems with many processors process oriented programming allows programmers to think about applications as sets of concurrent processes acting upon logically shared data structures just as different groups in software engineering advocate different methodologies different programming languages advocate different programming paradigms some languages are designed to support one particular paradigm smalltalk supports object oriented programming haskell supports functional programming while other programming languages support multiple paradigms such as object pascal c java c scala visual basic common lisp scheme perl python ruby oz and f many programming paradigms are as well known for what techniques they forbid as for what they enable for instance pure functional programming disallows the use of side effects while structured programming disallows the use of the goto statement partly for this reason new paradigms are often regarded as doctrinaire or overly rigid by those accustomed to earlier styles 2 avoiding certain techniques can make it easier to prove theorems about a program s correctness or simply to understand its behavior edit multi paradigm programming language see also list of multi paradigm programming languages a multi paradigm programming language is a programming language that supports more than one programming paradigm citation needed as leda designer timothy budd puts it the idea of a multiparadigm language is to provide a framework in which programmers can work in a variety of styles freely intermixing constructs from different paradigms the design goal of such languages is to allow programmers to use the best tool for a job admitting that no one paradigm solves all problems in the easiest or most efficient way one example is c which includes imperative and object oriented paradigms as well as some support for functional programming through type inference anonymous functions and language integrated query some other ones are f and scala which provides similar functionality to c but also includes full support for functional programming including currying pattern matching algebraic data types lazy evaluation tail recursion immutability etc perhaps the most extreme example is oz which has subsets that are logic oz descends from logic programming a functional an object oriented a dataflow concurrent and other language paradigms oz was designed over a ten year period to combine in a harmonious way concepts that are traditionally associated with different programming paradigms lisp while often taught as a functional language is known for its malleability and thus its ability to engulf many paradigms edit history the lowest level programming paradigms are machine code which directly represents the instructions the contents of program memory as a sequence of numbers and assembly language where the machine instructions are represented by mnemonics and memory addresses can be given symbolic labels these are sometimes called first and second generation languages in the 1960s assembly languages were developed to support library copy and quite sophisticated conditional macro generation and pre processing capabilities call to subroutines external variables and common sections globals enabling significant code re use and isolation from hardware specifics via use of logical operators such as read write get put assembly was and still is used for time critical systems and frequently in embedded systems as it gives the most direct control of what the machine actually does the next advance was the development of procedural languages these third generation languages the first described as high level languages use vocabulary related to the problem being solved for example c developed c 1970 at bell labs cobol common business oriented language uses terms like file move and copy fortran formula translation using mathematical language terminology it was developed mainly for scientific and engineering problems algol algorithmic language focused on being an appropriate language to define algorithms while using mathematical language terminology and targeting scientific and engineering problems just like fortran pl i programming language one a hybrid commercial scientific general purpose language supporting pointers basic beginners all purpose symbolic instruction code was developed to enable more people to write programs all these languages follow the procedural paradigm that is they describe step by step exactly the procedure that should according to the particular programmer at least be followed to solve a specific problem the efficacy and efficiency of any such solution are both therefore entirely subjective and highly dependent on that programmer s experience inventiveness and ability later object oriented languages like simula smalltalk c eiffel and java were created in these languages data and methods of manipulating the data are kept as a single unit called an object the only way that a user can access the data is via the object s methods subroutines because of this the internal workings of an object may be changed without affecting any code that uses the object there is still some controversy by notable programmers such as alexander stepanov richard stallman 3 and others concerning the efficacy of the oop paradigm versus the procedural paradigm the necessity of every object to have associative methods leads some skeptics to associate oop with software bloat polymorphism was developed as one attempt to resolve this dilemma since object oriented programming is considered a paradigm not a language it is possible to create even an object oriented assembler language high level assembly hla is an example of this that fully supports advanced data types and object oriented assembly language programming despite its early origins thus differing programming paradigms can be thought of as more like motivational memes of their advocates rather than necessarily representing progress from one level to the next precise comparisons of the efficacy of competing paradigms are frequently made more difficult because of new and differing terminology applied to similar but not identical entities and processes together with numerous implementation distinctions across languages within imperative programming which is based on procedural languages an alternative to the computer centered hierarchy of structured programming is literate programming which structures programs instead as a human centered web as in a hypertext essay documentation is integral to the program and the program is structured following the logic of prose exposition rather than compiler convenience independent of the imperative branch declarative programming paradigms were developed in these languages the computer is told what the problem is not how to solve the problem the program is structured as a collection of properties to find in the expected result not as a procedure to follow given a database or a set of rules the computer tries to find a solution matching all the desired properties the archetypical example of a declarative language is the fourth generation language sql as well as the family of functional languages and logic programming functional programming is a subset of declarative programming programs written using this paradigm use functions blocks of code intended to behave like mathematical functions functional languages discourage changes in the value of variables through assignment making a great deal of use of recursion instead the logic programming paradigm views computation as automated reasoning over a corpus of knowledge facts about the problem domain are expressed as logic formulae and programs are executed by applying inference rules over them until an answer to the problem is found or the collection of formulae is proved inconsistent edit see also comparison of programming paradigms type system architecture description language domain specific language mindset modeling language paradigm programming domain turing completeness edit references n rmark kurt overview of the four main programming paradigms aalborg university 9 may 2011 retrieved 22 september 2012 frank rubin published a criticism of dijkstra s letter in the march 1987 cacm where it appeared under the title goto considered harmful considered harmful frank rubin march 1987 goto considered harmful considered harmful pdf communications of the acm 30 3 195 196 doi 10 1145 214748 315722 http www ecn purdue edu paramount papers rubin87goto pdf dead link mode inheritance cloning hooks amp oop google groups discussion http groups google com group comp emacs xemacs browse thread thread d0af257a2837640c 37f251537fafbb03 lnk st amp q 22richard stallman 22 oop amp rnum 5 amp hl en 37f251537fafbb03 dead link edit external links programming language lists alphabetical categorical chronological generational v t e classification of the principal programming paradigms 160 links to related articles 160 software engineering v t e types of computer languages architecture description hardware description markup modeling programming query specification stylesheet template processing transformation v t e software engineering fields computer programming formal methods requirements analysis software deployment software design software maintenance software testing systems analysis concepts data modeling enterprise architecture functional specification modeling language orthogonality programming paradigm software software architecture software development methodology software development process software quality software quality assurance software archaeology structured analysis orientations agile aspect oriented object orientation ontology service orientation sdlc models developmental agile eup executable uml incremental model iterative model rup scrum prototype model spiral model v model waterfall model xp other spice cmmi data model er model function model information model metamodeling object model systems model view model languages idef uml sysml software engineers kent beck grady booch fred brooks barry boehm peter chen ward cunningham ole johan dahl tom demarco martin fowler c a r hoare watts humphrey michael a jackson ivar jacobson james martin stephen j mellor bertrand meyer david parnas winston w royce james rumbaugh niklaus wirth edward yourdon victor basili related fields computer science computer engineering enterprise engineering history management project management quality management software ergonomics systems engineering category commons v t e major fields of computer science mathematical foundations mathematical logic set theory number theory graph theory type theory category theory numerical analysis information theory combinatorics boolean algebra theory of computation automata theory computability theory computational complexity theory quantum computing theory algorithms data structures analysis of algorithms algorithm design computational geometry programming languages compilers parsers interpreters procedural programming object oriented programming functional programming logic programming programming paradigms concurrent parallel distributed systems multiprocessing grid computing concurrency control software engineering requirements analysis software design computer programming formal methods software testing software development process system architecture computer architecture computer organization operating systems telecommunication networking computer audio routing network topology cryptography databases database management systems relational databases sql transactions database indexes data mining artificial intelligence automated reasoning computational linguistics computer vision evolutionary computation expert systems machine learning natural language processing robotics computer graphics visualization computer animation image processing human computer interaction computer accessibility user interfaces wearable computing ubiquitous computing virtual reality scientific computing artificial life bioinformatics cognitive science computational chemistry computational neuroscience computational physics numerical algorithms symbolic mathematics note computer science can also be divided into different topics or fields according to the acm computing classification system 160 programming v t e programming language generations generations overview 1gl 2gl 3gl 4gl 5gl v t e programming languages comparison timeline categorical list generational list alphabetical list non english based v t e types of programming languages array aspect oriented assembly class based compiled concatenative concurrent data structured dataflow declarative domain specific dynamic esoteric event driven extensible functional high level imperative interpreted logic low level machine macro metaprogramming multi paradigm non english based object based object oriented off side rule pipeline procedural prototype based reflective rule based scripting synchronous very high level visual 