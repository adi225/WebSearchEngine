parse redirects here for other uses see parse disambiguation parser redirects here for the computer programming language see parser cgi language parsing or syntactic analysis is the process of analysing a string of symbols either in natural language or in computer languages according to the rules of a formal grammar the term parsing comes from latin pars r ti nis meaning part of speech 1 2 the term has slightly different meanings in different branches of linguistics and computer science traditional sentence parsing is often performed as a pedagogical exercise especially in inflected languages such as the romance languages or latin sometimes with the aid of devices such as sentence diagrams it usually emphasizes the importance of grammatical divisions such as subject and predicate within computational linguistics the term is used to refer to the formal analysis by computer of a sentence or other string of words into its constituents resulting in a parse tree showing their syntactic relation to each other which may also contain semantic and other information the term is also used in psycholinguistics when describing language comprehension in this context parsing refers to the way that human beings analyze a sentence or phrase in spoken language or text in terms of grammatical constituents identifying the parts of speech syntactic relations etc 2 this term is especially common when discussing what linguistic cues help speakers to interpret garden path sentences within computer science the term is used in the analysis of computer languages referring to the syntactic analysis of the input code into its component parts in order to facilitate the writing of compilers and interpreters contents 1 human languages 1 1 traditional methods 1 2 computational methods 1 3 psycholinguistics 2 programming languages 2 1 parser 2 2 overview of process 3 types of parser 4 examples of parsers 4 1 top down parsers 4 2 bottom up parsers 4 3 parser development software 5 lookahead 6 see also 7 references 8 further reading 9 external links edit human languages edit traditional methods the traditional grammatical exercise of parsing sometimes known as clause analysis involves breaking down a text into its component parts of speech with an explanation of the form function and syntactic relationship of each part 3 this is determined in large part from study of the language s conjugations and declensions which can be quite intricate for heavily inflected languages to parse a phrase such as man bites dog involves noting that the singular noun man is the subject of the sentence the verb bites is the third person singular of the present tense of the verb to bite and the singular noun dog is the object of the sentence techniques such as sentence diagrams are sometimes used to indicate the relation between elements in the sentence parsing was formerly central to the teaching of grammar throughout the english speaking world and widely regarded as basic to the use and understanding of written language however the teaching of such techniques is no longer current edit computational methods see also category natural language parsing in some machine translation and natural language processing systems human languages are parsed by computer programs human sentences are not easily parsed by programs as there is substantial ambiguity in the structure of human language whose usage is to convey meaning or semantics amongst a potentially unlimited range of possibilities but only some of which are germane to the particular case so an utterance man bites dog versus dog bites man is definite on one detail but in another language might appear as man dog bites with a reliance on the larger context to distinguish between those two possibilities if indeed that difference was of concern it is difficult to prepare formal rules to describe informal behaviour even though it is clear that some rules are being followed in order to parse natural language data researchers must first agree on the grammar to be used the choice of syntax is affected by both linguistic and computational concerns for instance some parsing systems use lexical functional grammar but in general parsing for grammars of this type is known to be np complete head driven phrase structure grammar is another linguistic formalism which has been popular in the parsing community but other research efforts have focused on less complex formalisms such as the one used in the penn treebank shallow parsing aims to find only the boundaries of major constituents such as noun phrases another popular strategy for avoiding linguistic controversy is dependency grammar parsing most modern parsers are at least partly statistical that is they rely on a corpus of training data which has already been annotated parsed by hand this approach allows the system to gather information about the frequency with which various constructions occur in specific contexts see machine learning approaches which have been used include straightforward pcfgs probabilistic context free grammars maximum entropy and neural nets most of the more successful systems use lexical statistics that is they consider the identities of the words involved as well as their part of speech however such systems are vulnerable to overfitting and require some kind of smoothing to be effective citation needed parsing algorithms for natural language cannot rely on the grammar having nice properties as with manually designed grammars for programming languages as mentioned earlier some grammar formalisms are very difficult to parse computationally in general even if the desired structure is not context free some kind of context free approximation to the grammar is used to perform a first pass algorithms which use context free grammars often rely on some variant of the cky algorithm usually with some heuristic to prune away unlikely analyses to save time see chart parsing however some systems trade speed for accuracy using e g linear time versions of the shift reduce algorithm a somewhat recent development has been parse reranking in which the parser proposes some large number of analyses and a more complex system selects the best option edit psycholinguistics in psycholinguistics parsing involves not just the assignment of words to categories but the evaluation of the meaning of a sentence according to the rules of syntax drawn by inferences made from each word in the sentence this normally occurs as words are being heard or read consequently psycholinguistic models of parsing are of necessity incremental meaning that they build up an interpretation as the sentence is being processed which is normally expressed in terms of a partial syntactic structure creation of the wrong structure can lead to the phenomenon known as garden pathing edit programming languages edit parser in computing a parser is one of the components in an interpreter or compiler that checks for correct syntax and builds a data structure often some kind of parse tree abstract syntax tree or other hierarchical structure implicit in the input tokens the parser often uses a separate lexical analyser to create tokens from the sequence of input characters parsers may be programmed by hand or may be semi automatically generated in some programming languages by a tool the most common use of a parser is as a component of a compiler or interpreter this parses the source code of a computer programming language to create some form of internal representation programming languages tend to be specified in terms of a context free grammar because fast and efficient parsers can be written for them parsers are written by hand or generated by parser generators context free grammars are limited in the extent to which they can express all of the requirements of a language informally the reason is that the memory of such a language is limited the grammar cannot remember the presence of a construct over an arbitrarily long input this is necessary for a language in which for example a name must be declared before it may be referenced more powerful grammars that can express this constraint however cannot be parsed efficiently thus it is a common strategy to create a relaxed parser for a context free grammar which accepts a superset of the desired language constructs that is it accepts some invalid constructs later the unwanted constructs can be filtered out edit overview of process the following example demonstrates the common case of parsing a computer language with two levels of grammar lexical and syntactic the first stage is the token generation or lexical analysis by which the input character stream is split into meaningful symbols defined by a grammar of regular expressions for example a calculator program would look at an input such as 12 3 4 2 and split it into the tokens 12 3 4 2 each of which is a meaningful symbol in the context of an arithmetic expression the lexer would contain rules to tell it that the characters and mark the start of a new token so meaningless tokens like 12 or 3 will not be generated the next stage is parsing or syntactic analysis which is checking that the tokens form an allowable expression this is usually done with reference to a context free grammar which recursively defines components that can make up an expression and the order in which they must appear however not all rules defining programming languages can be expressed by context free grammars alone for example type validity and proper declaration of identifiers these rules can be formally expressed with attribute grammars the final phase is semantic parsing or analysis which is working out the implications of the expression just validated and taking the appropriate action in the case of a calculator or interpreter the action is to evaluate the expression or program a compiler on the other hand would generate some kind of code attribute grammars can also be used to define these actions edit types of parser the task of the parser is essentially to determine if and how the input can be derived from the start symbol of the grammar this can be done in essentially two ways top down parsing top down parsing can be viewed as an attempt to find left most derivations of an input stream by searching for parse trees using a top down expansion of the given formal grammar rules tokens are consumed from left to right inclusive choice is used to accommodate ambiguity by expanding all alternative right hand sides of grammar rules 4 bottom up parsing a parser can start with the input and attempt to rewrite it to the start symbol intuitively the parser attempts to locate the most basic elements then the elements containing these and so on lr parsers are examples of bottom up parsers another term used for this type of parser is shift reduce parsing ll parsers and recursive descent parser are examples of top down parsers which cannot accommodate left recursive production rules although it has been believed that simple implementations of top down parsing cannot accommodate direct and indirect left recursion and may require exponential time and space complexity while parsing ambiguous context free grammars more sophisticated algorithms for top down parsing have been created by frost hafiz and callaghan 5 6 which accommodate ambiguity and left recursion in polynomial time and which generate polynomial size representations of the potentially exponential number of parse trees their algorithm is able to produce both left most and right most derivations of an input with regard to a given cfg context free grammar an important distinction with regard to parsers is whether a parser generates a leftmost derivation or a rightmost derivation see context free grammar ll parsers will generate a leftmost derivation and lr parsers will generate a rightmost derivation although usually in reverse 4 edit examples of parsers edit top down parsers some of the parsers that use top down parsing include recursive descent parser ll parser l eft to right l eftmost derivation earley parser edit bottom up parsers some of the parsers that use bottom up parsing include precedence parser operator precedence parser simple precedence parser bc bounded context parsing lr parser l eft to right r ightmost derivation simple lr slr parser lalr parser canonical lr lr 1 parser glr parser cyk parser edit parser development software some of the well known parser development tools include the following also see comparison of parser generators antlr bison coco r gold javacc lemon lex parboiled parseit ragel shproto fsm parser language 7 spirit parser framework syntax definition formalism syntax visuallanglab xpl yacc edit lookahead this section does not cite any references or sources please help improve this section by adding citations to reliable sources unsourced material may be challenged and removed april 2012 lookahead establishes the maximum incoming tokens that a parser can use to decide which rule it should use lookahead is especially relevant to ll lr and lalr parsers where it is often explicitly indicated by affixing the lookahead to the algorithm name in parentheses such as lalr 1 most programming languages the primary target of parsers are carefully defined in such a way that a parser with limited lookahead typically one can parse them because parsers with limited lookahead are often more efficient one important change citation needed to this trend came in 1990 when terence parr created antlr for his ph d thesis a parser generator for efficient ll k parsers where k is any fixed value parsers typically have only a few actions after seeing each token they are shift add this token to the stack for later reduction reduce pop tokens from the stack and form a syntactic construct end error no known rule applies or conflict does not know whether to shift or reduce lookahead has two advantages it helps the parser take the correct action in case of conflicts for example parsing the if statement in the case of an else clause it eliminates many duplicate states and eases the burden of an extra stack a c language non lookahead parser will have around 10 000 states a lookahead parser will have around 300 states example parsing the expression 1 2 3 set of expression parsing rules called grammar is as follows rule1 e e e expression is the sum of two expressions rule2 e e e expression is the product of two expressions rule3 e number expression is a simple number rule4 has less precedence than most programming languages except for a few such as apl and smalltalk and algebraic formulas give higher precedence to multiplication than addition in which case the correct interpretation of the example above is 1 2 3 note that rule4 above is a semantic rule it is possible to rewrite the grammar to incorporate this into the syntax however not all such rules can be translated into syntax simple non lookahead parser actions reduces 1 to expression e on input 1 based on rule3 shift onto stack on input 1 in anticipation of rule1 reduce stack element 2 to expression e based on rule3 reduce stack items e and new input e to e based on rule1 shift onto stack on input in anticipation of rule2 shift 3 onto stack on input 3 in anticipation of rule3 reduce 3 to expression e on input 3 based on rule3 reduce stack items e and new input e to e based on rule2 the parse tree and resulting code from it is not correct according to language semantics to correctly parse without lookahead there are three solutions the user has to enclose expressions within parentheses this often is not a viable solution the parser needs to have more logic to backtrack and retry whenever a rule is violated or not complete the similar method is followed in ll parsers alternatively the parser or grammar needs to have extra logic to delay reduction and reduce only when it is absolutely sure which rule to reduce first this method is used in lr parsers this correctly parses the expression but with many more states and increased stack depth lookahead parser actions shift 1 onto stack on input 1 in anticipation of rule3 it does not reduce immediately reduce stack item 1 to simple expression on input based on rule3 the lookahead is so we are on path to e so we can reduce the stack to e shift onto stack on input in anticipation of rule1 shift 2 onto stack on input 2 in anticipation of rule3 reduce stack item 2 to expression on input based on rule3 the lookahead expects only e before it now stack has e e and still the input is it has two choices now either to shift based on rule2 or reduction based on rule1 since has more precedence than based on rule4 so shift onto stack in anticipation of rule2 shift 3 onto stack on input 3 in anticipation of rule3 reduce stack item 3 to expression after seeing end of input based on rule3 reduce stack items e e to e based on rule2 reduce stack items e e to e based on rule1 the parse tree generated is correct and simply more efficient citation needed than non lookahead parsers this is the strategy followed in lalr parsers edit see also backtracking chart parser compiler compiler deterministic parsing generating strings grammar checker lalr parser lexing pratt parser shallow parsing left corner parser parsing expression grammar edit references bartleby com homepage http www bartleby com 61 33 p0083300 html retrieved 28 november 2010 a b parse dictionary reference com http dictionary reference com search q parse amp x 0 amp y 0 retrieved 27 november 2010 grammar and composition http grammar about com od pq g parsingterm htm a b aho a v sethi r and ullman j d 1986 compilers principles techniques and tools addison wesley longman publishing co inc boston ma usa frost r hafiz r and callaghan p 2007 modular and efficient top down parsing for ambiguous left recursive grammars 10th international workshop on parsing technologies iwpt acl sigparse pages 109 120 june 2007 prague frost r hafiz r and callaghan p 2008 parser combinators for ambiguous left recursive grammars 10th international symposium on practical aspects of declarative languages padl acm sigplan volume 4902 2008 pages 167 181 january 2008 san francisco shproto org edit further reading chapman nigel p lr parsing theory and practice cambridge university press 1987 isbn 0 521 30413 x grune dick jacobs ceriel j h parsing techniques a practical guide vrije universiteit amsterdam amsterdam the netherlands originally published by ellis horwood chichester england 1990 isbn 0 13 651431 6 edit external links look up parse in wiktionary the free dictionary the lemon lalr parser generator 