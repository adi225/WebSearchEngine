this article needs additional citations for verification please help improve this article by adding citations to reliable sources unsourced material may be challenged and removed january 2013 software development process a software engineer programming at work activities and steps requirements specification architecture design implementation testing debugging deployment maintenance methodologies waterfall prototype model incremental iterative v model spiral scrum cleanroom rad dsdm rup xp agile lean dual vee model tdd fdd supporting disciplines configuration management documentation quality assurance sqa project management user experience design tools compiler debugger profiler gui designer ide build automation v t e software design is a process of problem solving and planning for a software solution after the purpose and specifications of software are determined software developers will design or employ designers to develop a plan for a solution it includes low level component and algorithm implementation issues as well as the architectural view contents 1 overview 2 software design topics 2 1 design concepts 2 2 design considerations 2 3 modeling language 2 4 design patterns 2 5 usage 3 see also 4 references edit overview the software requirements analysis sra step of a software development process yields specifications that are used in software engineering if the software is semiautomated or user centered software design may involve user experience design yielding a story board to help determine those specifications if the software is completely automated meaning no user or user interface a software design may be as simple as a flow chart or text describing a planned sequence of events there are also semi standard methods like unified modeling language and fundamental modeling concepts in either case some documentation of the plan is usually the product of the design a software design may be platform independent or platform specific depending on the availability of the technology called for by the design software design can be considered as putting solution to the problem s in hand using the available capabilities hence the main difference between software analysis and design is that the output of the analysis of a software problem will be smaller problems to solve and it should not deviate so much even if it is conducted by different team members or even by entirely different groups but since design depends on the capabilities we can have different designs for the same problem depending on the capabilities of the environment that will host the solution whether it is some os web mobile or even the new cloud computing paradigm the solution will depend also on the used development environment whether you build a solution from scratch or using reliable frameworks or at least implement some suitable design patterns edit software design topics edit design concepts the design concepts provide the software designer with a foundation from which more sophisticated methods can be applied a set of fundamental design concepts has evolved they are abstraction abstraction is the process or result of generalization by reducing the information content of a concept or an observable phenomenon typically in order to retain only information which is relevant for a particular purpose refinement it is the process of elaboration a hierarchy is developed by decomposing a macroscopic statement of function in a stepwise fashion until programming language statements are reached in each step one or several instructions of a given program are decomposed into more detailed instructions abstraction and refinement are complementary concepts modularity software architecture is divided into components called modules software architecture it refers to the overall structure of the software and the ways in which that structure provides conceptual integrity for a system a good software architecture will yield a good return on investment with respect to the desired outcome of the project e g in terms of performance quality schedule and cost control hierarchy a program structure that represents the organization of a program component and implies a hierarchy of control structural partitioning the program structure can be divided both horizontally and vertically horizontal partitions define separate branches of modular hierarchy for each major program function vertical partitioning suggests that control and work should be distributed top down in the program structure data structure it is a representation of the logical relationship among individual elements of data software procedure it focuses on the processing of each modules individually information hiding modules should be specified and designed so that information contained within a module is inaccessible to other modules that have no need for such information edit design considerations there are many aspects to consider in the design of a piece of software the importance of each should reflect the goals the software is trying to achieve some of these aspects are compatibility the software is able to operate with other products that are designed for interoperability with another product for example a piece of software may be backward compatible with an older version of itself extensibility new capabilities can be added to the software without major changes to the underlying architecture fault tolerance the software is resistant to and able to recover from component failure maintainability a measure of how easily bug fixes or functional modifications can be accomplished high maintainability can be the product of modularity and extensibility modularity the resulting software comprises well defined independent components that leads to better maintainability the components could be then implemented and tested in isolation before being integrated to form a desired software system this allows division of work in a software development project reliability the software is able to perform a required function under stated conditions for a specified period of time reusability the software is able to add further features and modification with slight or no modification robustness the software is able to operate under stress or tolerate unpredictable or invalid input for example it can be designed with a resilience to low memory conditions security the software is able to withstand hostile acts and influences usability the software user interface must be usable for its target user audience default values for the parameters must be chosen so that they are a good choice for the majority of the users edit modeling language a modeling language is any artificial language that can be used to express information or knowledge or systems in a structure that is defined by a consistent set of rules the rules are used for interpretation of the meaning of components in the structure a modeling language can be graphical or textual examples of graphical modeling languages for software design are business process modeling notation bpmn is an example of a process modeling language express and express g iso 10303 11 is an international standard general purpose data modeling language extended enterprise modeling language eeml is commonly used for business process modeling across a number of layers flowchart is a schematic representation of an algorithm or a stepwise process fundamental modeling concepts fmc modeling language for software intensive systems idef is a family of modeling languages the most notable of which include idef0 for functional modeling idef1x for information modeling and idef5 for modeling ontologies jackson structured programming jsp is a method for structured programming based on correspondences between data stream structure and program structure lepus3 is an object oriented visual design description language and a formal specification language that is suitable primarily for modelling large object oriented java c c programs and design patterns unified modeling language uml is a general modeling language to describe software both structurally and behaviorally it has a graphical notation and allows for extension with a profile uml alloy specification language is a general purpose specification language for expressing complex structural constraints and behavior in a software system it provides a concise language based on first order relational logic systems modeling language sysml is a new general purpose modeling language for systems engineering edit design patterns a software designer or architect may identify a design problem which has been solved by others before a template or pattern describing a solution to a common problem is known as a design pattern the reuse of such patterns can speed up the software development process having been tested and proven in the past edit usage software design documentation may be reviewed or presented to allow constraints specifications and even requirements to be adjusted prior to programming redesign may occur after review of a programmed simulation or prototype it is possible to design software in the process of programming without a plan or requirement analysis 1 but for more complex projects this would not be considered a professional approach a separate design prior to programming allows for multidisciplinary designers and subject matter experts smes to collaborate with highly skilled programmers for software that is both useful and technically sound edit see also wikimedia commons has media related to software design aspect oriented software development bachelor of science in information technology design rationale interaction design icon design search based software engineering software design description ieee 1016 software development user experience user interface design zero one infinity edit references ralph p and wand y a proposal for a formal definition of the design concept in lyytinen k loucopoulos p mylopoulos j and robinson w eds design requirements engineering a ten year perspective springer verlag 2009 pp 103 136 v t e major fields of computer science mathematical foundations mathematical logic set theory number theory graph theory type theory category theory numerical analysis information theory combinatorics boolean algebra theory of computation automata theory computability theory computational complexity theory quantum computing theory algorithms data structures analysis of algorithms algorithm design computational geometry programming languages compilers parsers interpreters procedural programming object oriented programming functional programming logic programming programming paradigms concurrent parallel distributed systems multiprocessing grid computing concurrency control software engineering requirements analysis software design computer programming formal methods software testing software development process system architecture computer architecture computer organization operating systems telecommunication networking computer audio routing network topology cryptography databases database management systems relational databases sql transactions database indexes data mining artificial intelligence automated reasoning computational linguistics computer vision evolutionary computation expert systems machine learning natural language processing robotics computer graphics visualization computer animation image processing human computer interaction computer accessibility user interfaces wearable computing ubiquitous computing virtual reality scientific computing artificial life bioinformatics cognitive science computational chemistry computational neuroscience computational physics numerical algorithms symbolic mathematics note computer science can also be divided into different topics or fields according to the acm computing classification system v t e software engineering fields computer programming formal methods requirements analysis software deployment software design software maintenance software testing systems analysis concepts data modeling enterprise architecture functional specification modeling language orthogonality programming paradigm software software architecture software development methodology software development process software quality software quality assurance software archaeology structured analysis orientations agile aspect oriented object orientation ontology service orientation sdlc models developmental agile eup executable uml incremental model iterative model rup scrum prototype model spiral model v model waterfall model xp other spice cmmi data model er model function model information model metamodeling object model systems model view model languages idef uml sysml software engineers kent beck grady booch fred brooks barry boehm peter chen ward cunningham ole johan dahl tom demarco martin fowler c a r hoare watts humphrey michael a jackson ivar jacobson james martin stephen j mellor bertrand meyer david parnas winston w royce james rumbaugh niklaus wirth edward yourdon victor basili related fields computer science computer engineering enterprise engineering history management project management quality management software ergonomics systems engineering category commons 